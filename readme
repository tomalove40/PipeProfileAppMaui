Содержимое папки:
[MPowerKit.TabView]
  Alignment.cs
  InverseBooleanConverter.cs
  ItemsPresenter.cs
  MPowerKit.TabView.csproj
  ScrollOrientationToStackOrientationConverter.cs
  TabVIew.cs
  TabViewHeaderItem.cs
  TabViewItem.cs
  TabViewStyle.xaml
  TabViewStyle.xaml.cs
[PipeProfileAppMaui]
  [.git]
    [hooks]
      applypatch-msg.sample
      commit-msg.sample
      fsmonitor-watchman.sample
      post-update.sample
      pre-applypatch.sample
      pre-commit.sample
      pre-merge-commit.sample
      pre-push.sample
      pre-rebase.sample
      pre-receive.sample
      prepare-commit-msg.sample
      push-to-checkout.sample
      sendemail-validate.sample
      update.sample
    [info]
      exclude
    [logs]
      [refs]
        [heads]
          master
        [remotes]
          [origin]
            master
      HEAD
    [objects]
      [00]
        04a4fdee5d5bd9dac769b3e6a2e17931938ac3
      [02]
        8420dc677f1b9def86c673060ef08696932b7b
      [05]
        1f4e35f2991ca446c5e114d391369b11e826ac
        3270d5d5db626cb62a5eb84b5ceaafb6f7ab0a
      [08]
        0cfb5926a87442d582f100c1582f43ccf19471
      [0b]
        b1e67fe277ba37f5be6b90d50059fca8514c7a
      [0d]
        b84a28cd99cac8bbc9ab12a58529a2fec5b1ff
      [0e]
        ddd7cfb20f54407588a0781b218d004e3f3bac
      [11]
        279c73ecd7f7f82257735e899e0411eea5ce7f
        51d9bd13a1edd10ae156c5b3517331ed2bc2b5
      [13]
        fbe643270d654a245f426f805397ce3818a01f
      [17]
        6a7da60c8f29ef97fd567919f722443437bdeb
      [1d]
        0460d315385cbae4e4fb0d822b912d563db9f6
        2936b44873d76e85209dac5731df3e7f740ff7
        2d2fb9901356429eb3275057b70c40e043e5ce
        b1992f91012a3633949e99d42eb69b8e2866f8
      [1e]
        e1fce7cbdae3647f4681c8d8d7fbf97f9b74fc
      [1f]
        f0c423042b46cb1d617b81efb715defbe8054d
      [21]
        5fe18d42350eaa924275231b5bc22a3129dbc3
        dfb25f187b2ff04d3b5a6f1913fe971f36b34b
      [23]
        99166e4b27f804f56844f549dcb3a97d84913e
        e11f7b03fc67dff8a36dab54212b303eec1318
      [24]
        ab3b4334cbaacb6dd58070ef0c0255f0a2a37e
      [25]
        52478b3aace23013035ebf158f7e0bf479f212
        7b8c113f3d3cad58c9f3015f1466af27e081b4
      [29]
        21400904a49672f3e881cbf7c272d2cd8dea49
      [2a]
        b55ebc8af8a08992bfd96ec27e78f492274749
      [2b]
        80de4dd1c1c899c5eda86dff5e9b71685462ad
      [2e]
        1cf19cf44c35717b8c6b7f1b39630a64f09df6
      [2f]
        d9875b862afc112cadfd04f6f9cef0dd13aac3
      [30]
        307a5ddc3b7f2894a389630562db7f3adfe125
      [33]
        275af651940d731ed7efe96959a3f1e4558742
        ca91d9c66d6f12f4c6b65a4486a8d2c96b4d14
      [37]
        8b71be1898f3f7bbe0a7bc8f1197625b078175
      [40]
        a8ed7e60e0738c3743f266658324917ae019a5
      [43]
        e17d7e4e20ca50f4fa0e0a2140ea282faaa99a
      [44]
        3e148ff9247f1eb0979aba9cd9d556b0ee29bf
      [47]
        178c6240cc70a2f1d0b4c487072ad3fc4c0368
      [4d]
        58853dff74fef98a9ef6a61d92ede548e7ae49
      [4f]
        857936f4f5123afe9f16318741b2adb1d746c4
        c7389574dbb65adb004018d9660a1bc0277a62
      [56]
        277540490cf17d8d37c3eabbb4c3a64eafe1fe
      [5a]
        20a7ecb3781c7eea5372a643eed163746103f8
        529b30dd955bd543ba3a9451d9def107df5ebf
      [5e]
        5abddbc784d4c8719bc53f19ed510063b64bd7
      [5f]
        c23b86c1bdeda25048d81d651e26140b6f80d0
      [63]
        66f14a2a86dcb15489e6c8ebd0aeb8a8da1ca1
      [64]
        bb238479434db92f0977b8bab9d6373b2af6b2
      [65]
        0d72e742a819f77dde0273d3471753f04e3828
        9182ee8c7dd62a770e801d56ac446c99d628e5
      [67]
        0c30b51a3a73a428ee51cd58fd52c5bf6c8173
        39d6d77c4470b77292dc8a6ae78f3f5a874398
      [6a]
        d7c22c3a37a8f2d5bf71c88aba41e55990d91c
      [6c]
        a4221b1eaf8c1d718f3a17ecf00f0e00ee0eb0
      [6d]
        1329f6e953b2dcd8341bab8cbd2d5f819c6a0e
      [6f]
        6244a10731c1a3ca63e76641f72423b31ef279
      [70]
        b8e4621fc00e5da76d9d8595b48e4189a96525
      [72]
        689771518af8ec02f4ade026db1016cf964e3c
      [76]
        f09a5742020cdc2fb0ef1cff09eab9b25ad0ce
      [7b]
        c3f388f128eda7ebded87427c8e244919fe64d
      [87]
        43c5405e54f5b52d202894cfe39f085f741779
      [89]
        dc758d6e0d8d5153cc9cfd5a0429af3e70fe59
      [8d]
        c7ff892a61772742632032de68cd7786f83132
      [90]
        5aa0d3802d0e267c2d73b2f08d31813ee23e9c
      [93]
        c78f7a20f1d2025c16281821b0f109955e0255
      [94]
        91a2fda28342ab358eaf234e1afe0c07a53d62
      [97]
        eb6eb2f0cce1785472345a30305ae174d9e85c
      [9d]
        63b6513a1ce21f50b73c50848461b52441e718
      [a1]
        db7d57971b5aa00cf4185d6f81b1327a5ebf21
      [a5]
        0ae4739a09653a22ba9b9f6d7068fa497c5f40
      [a8]
        a8fdbedcb01750a7e70f462d92954622f142d3
      [ac]
        baf9c00ef3405b0f6037c22963eaa0c08ed82c
      [ad]
        a0498dd7fa06173aeebbc62a534b9dcaf11588
      [af]
        f38685ca8dc6d78564468607586258393c2b8a
      [b5]
        24a819ab58d3feabbbe12440d1e8fa50b25b20
      [b6]
        a345ca5eb3161bd3e02d8a2add29ef9db22f5f
      [ba]
        28c3b7d815f2f4b1d40f71bab32602f019ab23
        dd83e8e5105f4a0ba77c77472968ef097046e3
      [bb]
        5abf67eacb4b6e9b484d68c34b3a29b6857c44
      [bc]
        00d51fd950737b9794131a679c3a8318e661bf
        81019ae9d76362b445ec330350158619c53a4e
      [be]
        0534c78da84ce05afd5b0ca8d86d1e2347de1c
      [bf]
        9657c3955fdbeea3b459f41b549169e1851812
        bf2dabb416e70dcfc9da3d5dacf3a3fa2d8936
      [c0]
        4d7492abf86f02e1b299625efd6f344af01e88
        fc820f5ccf7f2eb7b6d77a8f377f932cbfb972
      [c4]
        b7f2e3c82f933dcf0525064f480b34a45d5f6a
      [c5]
        efa6039e736add0479ed08c600076aa1c1efbd
      [c8]
        f9dca17fc72a86d5b4d5ade0ea01a14d7292e7
      [ca]
        a369a24e83736c6b5b772aacd4d75033ced83b
      [cb]
        a2a137ef41d01781dd5b079cbafcf40cbb3bc4
      [cc]
        25bbe6491e0f579f17b5ef2899396d56877aa1
        7d2e13f2186118969cb90e43a30f658c6a07d3
      [d3]
        cc5d6abe898073fcabc9b0f9b09df46730b684
      [d5]
        8a206feab98d76808d8f306c9ec628db45a57d
        a10b97175703c4ed57c885475ecc178da44181
      [d8]
        eca738e76c7df7ae011a2eae20b54b0dba3a75
      [dc]
        09b24e0705b70a5efba6dc00a445f2f565a83e
      [de]
        4adc94a9c9ed733679f565e2a4f1ab47c32555
      [e0]
        b2d24a483478cdddc643324c5a6b2a383391b6
      [e4]
        a428c829c266b4f03b2afd4fc7227bc66ec198
      [e7]
        239bcc14eaed1e6bb0b93f863ed04dea6c966b
      [e9]
        937ad77d515322ba687ee6b7508b5d191cd959
      [ec]
        b05eef985346849a63a0139de673f30a113a02
      [ee]
        3f28f4af33868de1d4ddaacdcdfbd1146d533f
        9be6181e4ab853955d33007100a9a1a4fe2362
      [f0]
        d3a70ceaa69fb70811f58254dc738e0f939eac
      [f3]
        3a75b0d918d9decd995193218203c9f5198a46
      [f5]
        f3c2fea2400618845d6e38f91bea83cdab9f80
      [f6]
        420c52ff544c12e696c5e2e29f932ca766086f
      [f8]
        c81340403de5c7de4c17373679aba298b5f3c3
      [f9]
        05e5c55e2d246f7ae5032f50e2f39108354c33
        09852438521278128a73b7914b435534adc55a
        3ce025a8aadac29138413514bef90c11d892d9
        bdf537e40734d2aad5e15e768b4425a21e7f5d
        c624de3011e6e0dcb3c9d6493ac188a97cb31a
      [fc]
        7daa637cd06a12ba6bfda5bb62c961aba4e0c2
      [fd]
        0986f6ebc3ec8f85b937d8790be44cbca065e6
      [fe]
        64a6e89f673ec24df97a18c86632adfd3248b8
      [info]
      [pack]
    [refs]
      [heads]
        master
      [remotes]
        [origin]
          master
      [tags]
    AUTO_MERGE
    COMMIT_EDITMSG
    config
    description
    FETCH_HEAD
    HEAD
    index
    MERGE_HEAD
    MERGE_MODE
    MERGE_MSG
    ms-persist.xml
    ORIG_HEAD
  [Controls]
    EditorManager.cs
    GroundPointsControl.xaml
    GroundPointsControl.xaml.cs
    PipePointsControl.xaml
    PipePointsControl.xaml.cs
    PipeProfileView.Drawing.cs
    PipeProfileView.Editor.cs
    PipeProfileView.Events.cs
    PipeProfileView.Init.cs
    PipeProfileView.xaml
    PipeProfileView.xaml.cs
    RibbonView.xaml
    RibbonView.xaml.cs
    SideTabView.xaml
    SideTabView.xaml.cs
    Stamp.cs
  [Converters]
    BoolToStateConverter.cs
    HeaderEqualsConverter.cs
    SelectedTabBackgroundConverter.cs
  [Helpers]
    DrawingHelpers.cs
    PageConfig.cs
    TextDrawingHelper.cs
  [Models]
    GroundPoint.cs
    PipePoint.cs
    StampCell.cs
  [MPowerKit.TabView]
    Alignment.cs
    InverseBooleanConverter.cs
    ItemsPresenter.cs
    MPowerKit.TabView.csproj
    ScrollOrientationToStackOrientationConverter.cs
    TabVIew.cs
    TabViewHeaderItem.cs
    TabViewItem.cs
    TabViewStyle.xaml
    TabViewStyle.xaml.cs
  [Platforms]
    [Android]
      [Resources]
        [Fonts]
          OpenSans-Regular.ttf
          OpenSans-Semibold.ttf
        [values]
          colors.xml
      AndroidManifest.xml
      MainActivity.cs
      MainApplication.cs
    [iOS]
      [Resources]
        PrivacyInfo.xcprivacy
      AppDelegate.cs
      Info.plist
      Program.cs
    [MacCatalyst]
      AppDelegate.cs
      Entitlements.plist
      Info.plist
      Program.cs
    [Tizen]
      Main.cs
      tizen-manifest.xml
    [Windows]
      app.manifest
      App.xaml
      App.xaml.cs
      Package.appxmanifest
  [Properties]
    [PublishProfiles]
      FolderProfile.pubxml
      FolderProfile.pubxml.user
    launchSettings.json
  [Resources]
    [AppIcon]
      appicon.svg
      appiconfg.svg
    [Fonts]
      gost-type-au.ttf
      OpenSans-Regular.ttf
      OpenSans-Semibold.ttf
    [Images]
      dotnet_bot.png
    [Raw]
      AboutAssets.txt
    [Splash]
      splash.svg
    [Styles]
      Colors.xaml
      Styles.xaml
      TabStyles.xaml
    [TabIcons]
      ground.jpg
      ground.svg
      pipe.jpg
      pipe.svg
  [Services]
    GroundCurveRenderer.cs
    IPipeRenderer.cs
    PipeCenterlineRenderer.cs
    PipeCurveRenderer.cs
    PipeProfileRenderer.cs
    PipeShapeRenderer.cs
    PipeTangentRenderer.cs
    ProfileRenderer.cs
    ProfileTableRenderer.cs
  [Transforms]
    ViewTransform.cs
  [ViewModels]
    GroundViewModel.cs
    MainViewModel.cs
    PipeViewModel.cs
    RibbonButtonItem.cs
    RibbonItems.cs
    RibbonItemTemplateSelector.cs
    RibbonViewModel.cs
  .gitattributes
  .gitignore
  App.xaml
  App.xaml.cs
  AppShell.xaml
  AppShell.xaml.cs
  MainPage.xaml
  MainPage.xaml.cs
  MauiProgram.cs
  PipeProfileAppMaui.csproj
  PipeProfileAppMaui.csproj.user
  PipeProfileAppMaui.sln
  ViewModelLocator.cs
icon.png
LICENSE
readme.md

==========================================

Файл: MPowerKit.TabView\Alignment.cs
namespace MPowerKit.TabView;

public enum Alignment
{
    Top,
    Bottom,
    Left,
    Right
}

Файл: MPowerKit.TabView\InverseBooleanConverter.cs
using System.Globalization;

namespace MPowerKit.TabView;

public class InverseBooleanConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is bool boolean)
        {
            return !boolean;
        }

        return value;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}

Файл: MPowerKit.TabView\ItemsPresenter.cs
namespace MPowerKit.TabView;

public class ItemsPresenter : ContentView
{
}

Файл: MPowerKit.TabView\MPowerKit.TabView.csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFrameworks>net8.0</TargetFrameworks>
		<UseMaui>true</UseMaui>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>

		<GeneratePackageOnBuild>True</GeneratePackageOnBuild>
		<Title>MPowerKit.TabView</Title>
		<Version>1.3.0</Version>
		<Authors>MPowerKit,Alex Dobrynin</Authors>
		<Description>Fully customizable .NET MAUI TabView</Description>
		<Copyright>MPowerKit</Copyright>
		<PackageProjectUrl>https://github.com/MPowerKit/TabView</PackageProjectUrl>
		<RepositoryUrl>https://github.com/MPowerKit/TabView</RepositoryUrl>
		<PackageTags>tab view;tabview;maui;tabbedview;tab;tabbed;tabs</PackageTags>
		<PackageLicenseFile>LICENSE</PackageLicenseFile>
		<PackageReadmeFile>readme.md</PackageReadmeFile>
		<PackageIcon>icon.png</PackageIcon>

		<GenerateTargetFrameworkAttribute>false</GenerateTargetFrameworkAttribute>
		<GenerateAssemblyInfo>false</GenerateAssemblyInfo>
		<GenerateAssemblyFileVersionAttribute>false</GenerateAssemblyFileVersionAttribute>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.Maui.Controls" Version="$(MauiVersion)" />
	</ItemGroup>

	<ItemGroup>
		<None Include="..\LICENSE">
			<Pack>True</Pack>
			<PackagePath>\</PackagePath>
		</None>
		<None Include="..\readme.md">
			<Pack>True</Pack>
			<PackagePath>\</PackagePath>
		</None>
		<None Include="..\icon.png">
			<Pack>True</Pack>
			<PackagePath>\</PackagePath>
		</None>
	</ItemGroup>

</Project>


Файл: MPowerKit.TabView\ScrollOrientationToStackOrientationConverter.cs
using System.Globalization;

namespace MPowerKit.TabView;

public class ScrollOrientationToStackOrientationConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is ScrollOrientation scrollOrientation)
        {
            return scrollOrientation switch
            {
                ScrollOrientation.Horizontal => StackOrientation.Horizontal,
                ScrollOrientation.Vertical => StackOrientation.Vertical,
                _ => throw new ArgumentOutOfRangeException(nameof(scrollOrientation), scrollOrientation, null)
            };
        }

        return StackOrientation.Horizontal;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}

Файл: MPowerKit.TabView\TabVIew.cs
using System.Collections;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Input;

namespace MPowerKit.TabView;

[ContentProperty("Tabs")]
public class TabView : ContentView
{
    protected Grid? ContentContainer;
    protected ScrollView? HeadersScroll;
    protected TabViewItem? PrevSelectedTabItem;
    protected Layout HeadersContainer;

    protected bool UseItemsSource => ItemsSource is not null;

    public ObservableCollection<TabViewItem> Tabs { get; } = [];

    protected Layout StackItemsLayout
    {
        get
        {
            var stack = new StackLayout()
            {
                VerticalOptions = LayoutOptions.Fill,
                HorizontalOptions = LayoutOptions.Fill,
                Spacing = 0,
                Orientation = StackOrientation.Horizontal
            };

            stack.SetBinding(StackLayout.OrientationProperty, new Binding(ScrollView.OrientationProperty.PropertyName,
                source: new RelativeBindingSource(RelativeBindingSourceMode.FindAncestor, typeof(ScrollView)),
                converter: new ScrollOrientationToStackOrientationConverter()));

            return stack;
        }
    }

    public TabView()
    {
        Tabs.CollectionChanged += Tabs_CollectionChanged;
    }

    protected override void OnApplyTemplate()
    {
        base.OnApplyTemplate();

        ContentContainer = GetTemplateChild("PART_ContentContainer") as Grid;
        HeadersScroll = GetTemplateChild("PART_HeadersScrollView") as ScrollView;

        InitHeaderBarLayout();
    }

    protected virtual void InitHeaderBarLayout()
    {
        if (HeadersScroll == null || HeadersScroll.Content is not ItemsPresenter presenter) return;

        var newLayout = HeaderItemsLayout ?? StackItemsLayout;

        if (HeadersContainer != null)
        {
            foreach (var item in HeadersContainer.Children)
            {
                newLayout.Children.Add(item);
            }

            HeadersContainer.Children.Clear();
        }

        HeadersContainer = newLayout;

        presenter.Content = HeadersContainer;
    }

    protected override void OnBindingContextChanged()
    {
        base.OnBindingContextChanged();

        if (BindingContext is not null && !UseItemsSource)
        {
            foreach (var tab in Tabs)
            {
                if (tab.BindingContext != BindingContext)
                    tab.BindingContext = BindingContext;
            }
        }
    }

    protected override void OnPropertyChanging([CallerMemberName] string? propertyName = null)
    {
        base.OnPropertyChanging(propertyName);

        if (propertyName == ItemsSourceProperty.PropertyName && ItemsSource is not null)
        {
            if (ItemsSource is INotifyCollectionChanged itemsSource)
                itemsSource.CollectionChanged -= ItemsSource_CollectionChanged;

            Tabs.Clear();
        }
        else if (propertyName == SelectedTabIndexProperty.PropertyName)
        {
            PrevSelectedTabItem = Tabs.ElementAtOrDefault(SelectedTabIndex);
        }
    }

    protected override void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        base.OnPropertyChanged(propertyName);

        if (propertyName == ItemsSourceProperty.PropertyName && ItemsSource is not null)
        {
            if (ItemsSource is INotifyCollectionChanged itemsSource)
                itemsSource.CollectionChanged += ItemsSource_CollectionChanged;

            InitItems(ItemsSource);
        }
        else if (propertyName == SelectedTabIndexProperty.PropertyName)
        {
            if (PrevSelectedTabItem is not null) PrevSelectedTabItem.IsSelected = false;

            var newTab = Tabs.ElementAtOrDefault(SelectedTabIndex);
            if (newTab is not null)
            {
                if (newTab.IsEnabled)
                {
                    newTab.IsSelected = true;
                }
                else
                {
                    SelectClosestEnabledTab(newTab);
                    return;
                }
            }

            if (SelectedTabChangedCommand?.CanExecute(SelectedTabChangedCommandParameter) is true)
                SelectedTabChangedCommand.Execute(SelectedTabChangedCommandParameter);
        }
        else if (propertyName == ContentTemplateProperty.PropertyName && UseItemsSource)
        {
            foreach (var tab in Tabs)
            {
                var index = Tabs.IndexOf(tab);
                InitTabContentTemplate(tab.BindingContext, tab);
            }
        }
        else if (propertyName == HeaderItemsLayoutProperty.PropertyName)
        {
            InitHeaderBarLayout();
        }
    }

    protected virtual void InitItems(IEnumerable source, int index = 0, bool useIndex = false)
    {
        if (source is null) return;

        foreach (var item in source)
        {
            var tabItem = new TabViewItem();
            InitTabContentTemplate(item, tabItem);

            tabItem.BindingContext = item;
            tabItem.Header = item;

            if (useIndex) Tabs.Insert(index, tabItem);
            else Tabs.Add(tabItem);
        }
    }

    protected virtual void InitTabContentTemplate(object item, TabViewItem tabItem)
    {
        if (ContentTemplate is not null)
        {
            var template = ContentTemplate;
            if (ContentTemplate is DataTemplateSelector selector) template = selector.SelectTemplate(item, this);

            var tabContent = template.CreateContent() as View;
            tabContent!.BindingContext ??= item;

            tabItem.Content = tabContent;
            return;
        }

        tabItem.Content = new Label
        {
            Text = item.ToString()
        };
    }

    protected virtual void ItemsSource_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        switch (e.Action)
        {
            case NotifyCollectionChangedAction.Add:
                ItemsAdd(e);
                break;
            case NotifyCollectionChangedAction.Move:
                ItemsMove(e);
                break;
            case NotifyCollectionChangedAction.Remove:
                ItemsRemove(e);
                break;
            case NotifyCollectionChangedAction.Replace:
                ItemsReplace(e);
                break;
            case NotifyCollectionChangedAction.Reset:
                ItemsReset(e);
                break;
        }
    }

    protected virtual void ItemsAdd(NotifyCollectionChangedEventArgs e)
    {
        InitItems(e.NewItems!, e.NewStartingIndex, true);
    }

    protected virtual void ItemsMove(NotifyCollectionChangedEventArgs e)
    {
        Tabs.Move(e.OldStartingIndex, e.NewStartingIndex);
    }

    protected virtual void ItemsRemove(NotifyCollectionChangedEventArgs e)
    {
        if (e.OldItems is null) return;

        if (e.OldStartingIndex + e.OldItems.Count < SelectedTabIndex)
        {
            SelectedTabIndex -= e.OldItems.Count;
        }
        else if (SelectedTabIndex >= e.OldStartingIndex
            && SelectedTabIndex <= e.OldStartingIndex + e.OldItems.Count)
        {
            var newIndex = e.OldStartingIndex + e.OldItems.Count + 1;
            if (newIndex > Tabs.Count) newIndex = -1;
            SelectedTabIndex = newIndex;
        }

        foreach (var item in e.OldItems)
        {
            Tabs.RemoveAt(e.OldStartingIndex);
        }
    }

    protected virtual void ItemsReplace(NotifyCollectionChangedEventArgs e)
    {
        ItemsRemove(e);
        ItemsAdd(e);
    }

    protected virtual void ItemsReset(NotifyCollectionChangedEventArgs e)
    {
        foreach (var item in Tabs)
        {
            item.PropertyChanged -= TabItem_PropertyChanged;
        }

        Tabs.Clear();

        InitItems(ItemsSource);
    }

    protected virtual void Tabs_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        switch (e.Action)
        {
            case NotifyCollectionChangedAction.Add:
                {
                    foreach (TabViewItem item in e.NewItems!)
                    {
                        item!.PropertyChanged += TabItem_PropertyChanged;

                        HeadersContainer?.Children.Insert(e.NewStartingIndex, item.TabViewHeaderItem);
                        ContentContainer?.Children.Insert(e.NewStartingIndex, item);
                    }

                    TabsInitialSelection(e);
                }
                break;
            case NotifyCollectionChangedAction.Move:
                {
                    if (HeadersContainer is not null)
                    {
                        var header = HeadersContainer.Children.ElementAt(e.OldStartingIndex);
                        HeadersContainer.Children.Remove(header);
                        HeadersContainer.Children.Insert(e.NewStartingIndex, header);
                    }

                    if (ContentContainer is not null)
                    {
                        var content = ContentContainer.Children.ElementAt(e.OldStartingIndex);
                        ContentContainer.Children.Remove(content);
                        ContentContainer.Children.Insert(e.NewStartingIndex, content);
                    }
                }
                break;
            case NotifyCollectionChangedAction.Remove:
                {
                    foreach (TabViewItem item in e.OldItems!)
                    {
                        item!.PropertyChanged -= TabItem_PropertyChanged;

                        HeadersContainer?.Children.RemoveAt(e.OldStartingIndex);
                        ContentContainer?.Children.RemoveAt(e.OldStartingIndex);
                    }
                }
                break;
            case NotifyCollectionChangedAction.Replace:
                break;
            case NotifyCollectionChangedAction.Reset:
                {
                    HeadersContainer?.Children.Clear();
                    ContentContainer?.Children.Clear();
                    SelectedTabIndex = -1;
                }
                break;
        }
    }

    protected virtual void TabsInitialSelection(NotifyCollectionChangedEventArgs e)
    {
        if (SelectedTabIndex == -1)
        {
            if (Tabs.Any(t => t.IsSelected))
            {
                SelectedTabIndex = Tabs.IndexOf(Tabs.First(t => t.IsSelected));
            }
            else
            {
                var tab = Tabs.First();
                if (!tab.IsEnabled) SelectClosestEnabledTab(tab);
                else SelectedTabIndex = 0;
            }
        }
        else
        {
            if (!Tabs.Any(t => t.IsSelected))
            {
                var tab = Tabs.ElementAtOrDefault(SelectedTabIndex);
                if (tab is null)
                {
                    if (Tabs.Count == 0) SelectedTabIndex = -1;
                    else SelectedTabIndex = 0;
                    return;
                }
                if (!tab.IsEnabled) SelectClosestEnabledTab(tab);
                else tab.IsSelected = true;
            }
            else if (e.NewStartingIndex <= SelectedTabIndex)
                SelectedTabIndex += (e.NewItems?.Count ?? 0) - (e.OldItems?.Count ?? 0);
        }
    }

    protected virtual void TabItem_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        var tab = (sender as TabViewItem)!;

        if (e.PropertyName == TabViewItem.IsSelectedProperty.PropertyName && tab.IsSelected)
        {
            if (!tab.IsEnabled)
            {
                SelectClosestEnabledTab(tab);
                return;
            }

            SelectedTabIndex = Tabs.IndexOf(tab);

            if (HeadersScroll is null || !ScrollToSelectedTab) return;

            if (HeaderBarAlignment is Alignment.Top or Alignment.Bottom
                && HeadersContainer.Width > HeadersScroll.Width)
            {
                var max = HeadersContainer.Width - HeadersScroll.Width;
                var scrollTo = tab.TabViewHeaderItem.X - (HeadersScroll.Width - tab.TabViewHeaderItem.Width) / 2.0;
                scrollTo = Math.Max(0d, Math.Min(max, scrollTo));

                HeadersScroll.ScrollToAsync(scrollTo, 0d, true);
            }
            else if (HeaderBarAlignment is Alignment.Left or Alignment.Right
                && HeadersContainer.Height > HeadersScroll.Height)
            {
                var max = HeadersContainer.Height - HeadersScroll.Height;
                var scrollTo = tab.TabViewHeaderItem.Y - (HeadersScroll.Height - tab.TabViewHeaderItem.Height) / 2.0;
                scrollTo = Math.Max(0d, Math.Min(max, scrollTo));

                HeadersScroll.ScrollToAsync(0d, scrollTo, true);
            }
        }
        else if (e.PropertyName == TabViewItem.IsEnabledProperty.PropertyName)
        {
            if (!tab.IsEnabled && tab.IsSelected) SelectClosestEnabledTab(tab);
            else if (tab.IsEnabled && !Tabs.Any(t => t.IsSelected))
            {
                var index = Tabs.IndexOf(tab);
                SelectedTabIndex = index;
            }
        }
    }

    protected virtual void SelectClosestEnabledTab(TabViewItem tab)
    {
        var tabs = Tabs.Where(t => t.IsEnabled || t == tab).ToList();

        if (tabs.Count == 1)
        {
            SelectedTabIndex = -1;
            return;
        }

        var index = tabs.IndexOf(tab);

        tabs[index + (index == tabs.Count - 1 ? -1 : 1)].IsSelected = true;
    }

    #region HideTabsWhenDisabled
    public bool HideTabsWhenDisabled
    {
        get { return (bool)GetValue(HideTabsWhenDisabledProperty); }
        set { SetValue(HideTabsWhenDisabledProperty, value); }
    }

    public static readonly BindableProperty HideTabsWhenDisabledProperty =
        BindableProperty.Create(
            nameof(HideTabsWhenDisabled),
            typeof(bool),
            typeof(TabView),
            true
            );
    #endregion

    #region HeaderItemsLayout
    public Layout HeaderItemsLayout
    {
        get { return (Layout)GetValue(HeaderItemsLayoutProperty); }
        set { SetValue(HeaderItemsLayoutProperty, value); }
    }

    public static readonly BindableProperty HeaderItemsLayoutProperty =
        BindableProperty.Create(
            nameof(HeaderItemsLayout),
            typeof(Layout),
            typeof(TabView)
            );
    #endregion

    #region ScrollToSelectedTab
    public bool ScrollToSelectedTab
    {
        get { return (bool)GetValue(ScrollToSelectedTabProperty); }
        set { SetValue(ScrollToSelectedTabProperty, value); }
    }

    public static readonly BindableProperty ScrollToSelectedTabProperty =
        BindableProperty.Create(
            nameof(ScrollToSelectedTab),
            typeof(bool),
            typeof(TabView),
            true
            );
    #endregion

    #region ContentBackgroundColor
    public Color ContentBackgroundColor
    {
        get { return (Color)GetValue(ContentBackgroundColorProperty); }
        set { SetValue(ContentBackgroundColorProperty, value); }
    }

    public static readonly BindableProperty ContentBackgroundColorProperty =
        BindableProperty.Create(
            nameof(ContentBackgroundColor),
            typeof(Color),
            typeof(TabView),
            Colors.Transparent
            );
    #endregion

    #region HeaderBarBackgroundColor
    public Color HeaderBarBackgroundColor
    {
        get { return (Color)GetValue(HeaderBarBackgroundColorProperty); }
        set { SetValue(HeaderBarBackgroundColorProperty, value); }
    }

    public static readonly BindableProperty HeaderBarBackgroundColorProperty =
        BindableProperty.Create(
            nameof(HeaderBarBackgroundColor),
            typeof(Color),
            typeof(TabView),
            Colors.Transparent
            );
    #endregion

    #region SelectedHeaderBackgroundColor
    public Color SelectedHeaderBackgroundColor
    {
        get { return (Color)GetValue(SelectedHeaderBackgroundColorProperty); }
        set { SetValue(SelectedHeaderBackgroundColorProperty, value); }
    }

    public static readonly BindableProperty SelectedHeaderBackgroundColorProperty =
        BindableProperty.Create(
            nameof(SelectedHeaderBackgroundColor),
            typeof(Color),
            typeof(TabView),
            Colors.Blue
            );
    #endregion

    #region HeaderBackgroundColor
    public Color HeaderBackgroundColor
    {
        get { return (Color)GetValue(HeaderBackgroundColorProperty); }
        set { SetValue(HeaderBackgroundColorProperty, value); }
    }

    public static readonly BindableProperty HeaderBackgroundColorProperty =
        BindableProperty.Create(
            nameof(HeaderBackgroundColor),
            typeof(Color),
            typeof(TabView),
            Colors.Transparent
            );
    #endregion

    #region HeaderHeightRequest
    public double HeaderHeightRequest
    {
        get { return (double)GetValue(HeaderHeightRequestProperty); }
        set { SetValue(HeaderHeightRequestProperty, value); }
    }

    public static readonly BindableProperty HeaderHeightRequestProperty =
        BindableProperty.Create(
            nameof(HeaderHeightRequest),
            typeof(double),
            typeof(TabView),
            50.0
            );
    #endregion

    #region HeaderFontFamily
    public string HeaderFontFamily
    {
        get { return (string)GetValue(HeaderFontFamilyProperty); }
        set { SetValue(HeaderFontFamilyProperty, value); }
    }

    public static readonly BindableProperty HeaderFontFamilyProperty =
        BindableProperty.Create(
            nameof(HeaderFontFamily),
            typeof(string),
            typeof(TabView)
            );
    #endregion

    #region HeaderFontSize
    public double HeaderFontSize
    {
        get { return (double)GetValue(HeaderFontSizeProperty); }
        set { SetValue(HeaderFontSizeProperty, value); }
    }

    public static readonly BindableProperty HeaderFontSizeProperty =
        BindableProperty.Create(
            nameof(HeaderFontSize),
            typeof(double),
            typeof(TabView),
            14.0
            );
    #endregion

    #region HeaderFontAttributes
    public FontAttributes HeaderFontAttributes
    {
        get { return (FontAttributes)GetValue(HeaderFontAttributesProperty); }
        set { SetValue(HeaderFontAttributesProperty, value); }
    }

    public static readonly BindableProperty HeaderFontAttributesProperty =
        BindableProperty.Create(
            nameof(HeaderFontAttributes),
            typeof(FontAttributes),
            typeof(TabView),
            FontAttributes.None
            );
    #endregion

    #region HeaderTextColor
    public Color HeaderTextColor
    {
        get { return (Color)GetValue(HeaderTextColorProperty); }
        set { SetValue(HeaderTextColorProperty, value); }
    }

    public static readonly BindableProperty HeaderTextColorProperty =
        BindableProperty.Create(
            nameof(HeaderTextColor),
            typeof(Color),
            typeof(TabView),
            Colors.Black
            );
    #endregion

    #region SelectedTabIndex
    public int SelectedTabIndex
    {
        get { return (int)GetValue(SelectedTabIndexProperty); }
        set { SetValue(SelectedTabIndexProperty, value); }
    }

    public static readonly BindableProperty SelectedTabIndexProperty =
        BindableProperty.Create(
            nameof(SelectedTabIndex),
            typeof(int),
            typeof(TabView),
            -1
            );
    #endregion

    #region SelectedHeaderTemplate
    public DataTemplate SelectedHeaderTemplate
    {
        get { return (DataTemplate)GetValue(SelectedHeaderTemplateProperty); }
        set { SetValue(SelectedHeaderTemplateProperty, value); }
    }

    public static readonly BindableProperty SelectedHeaderTemplateProperty =
        BindableProperty.Create(
            nameof(SelectedHeaderTemplate),
            typeof(DataTemplate),
            typeof(TabView)
            );
    #endregion

    #region HeaderTemplate
    public DataTemplate HeaderTemplate
    {
        get { return (DataTemplate)GetValue(HeaderTemplateProperty); }
        set { SetValue(HeaderTemplateProperty, value); }
    }

    public static readonly BindableProperty HeaderTemplateProperty =
        BindableProperty.Create(
            nameof(HeaderTemplate),
            typeof(DataTemplate),
            typeof(TabView)
            );
    #endregion

    #region ContentTemplate
    public DataTemplate ContentTemplate
    {
        get { return (DataTemplate)GetValue(ContentTemplateProperty); }
        set { SetValue(ContentTemplateProperty, value); }
    }

    public static readonly BindableProperty ContentTemplateProperty =
        BindableProperty.Create(
            nameof(ContentTemplate),
            typeof(DataTemplate),
            typeof(TabView)
            );
    #endregion

    #region ItemsSource
    public IEnumerable ItemsSource
    {
        get { return (IEnumerable)GetValue(ItemsSourceProperty); }
        set { SetValue(ItemsSourceProperty, value); }
    }

    public static readonly BindableProperty ItemsSourceProperty =
        BindableProperty.Create(
            nameof(ItemsSource),
            typeof(IEnumerable),
            typeof(TabView)
            );
    #endregion

    #region SelectedTabChangedCommand
    public ICommand SelectedTabChangedCommand
    {
        get { return (ICommand)GetValue(SelectedTabChangedCommandProperty); }
        set { SetValue(SelectedTabChangedCommandProperty, value); }
    }

    public static readonly BindableProperty SelectedTabChangedCommandProperty =
        BindableProperty.Create(
            nameof(SelectedTabChangedCommand),
            typeof(ICommand),
            typeof(TabView)
            );
    #endregion

    #region SelectedTabChangedCommandParameter
    public object SelectedTabChangedCommandParameter
    {
        get { return (object)GetValue(SelectedTabChangedCommandParameterProperty); }
        set { SetValue(SelectedTabChangedCommandParameterProperty, value); }
    }

    public static readonly BindableProperty SelectedTabChangedCommandParameterProperty =
        BindableProperty.Create(
            nameof(SelectedTabChangedCommandParameter),
            typeof(object),
            typeof(TabView)
            );
    #endregion

    #region HeaderBarAlignment
    public Alignment HeaderBarAlignment
    {
        get { return (Alignment)GetValue(HeaderBarAlignmentProperty); }
        set { SetValue(HeaderBarAlignmentProperty, value); }
    }

    public static readonly BindableProperty HeaderBarAlignmentProperty =
        BindableProperty.Create(
            nameof(HeaderBarAlignment),
            typeof(Alignment),
            typeof(TabView),
            Alignment.Top
            );
    #endregion

    // Новое свойство: как выравнивать заголовок по вертикали
    public LayoutOptions HeaderItemVerticalOptions
    {
        get => (LayoutOptions)GetValue(HeaderItemVerticalOptionsProperty);
        set => SetValue(HeaderItemVerticalOptionsProperty, value);
    }

    public static readonly BindableProperty HeaderItemVerticalOptionsProperty =
        BindableProperty.Create(
            nameof(HeaderItemVerticalOptions),
            typeof(LayoutOptions),
            typeof(TabView),
            LayoutOptions.Center // старая логика: по центру
        );

    // Новое свойство: как выравнивать заголовок по горизонтали (опционально)
    public LayoutOptions HeaderItemHorizontalOptions
    {
        get => (LayoutOptions)GetValue(HeaderItemHorizontalOptionsProperty);
        set => SetValue(HeaderItemHorizontalOptionsProperty, value);
    }

    public static readonly BindableProperty HeaderItemHorizontalOptionsProperty =
        BindableProperty.Create(
            nameof(HeaderItemHorizontalOptions),
            typeof(LayoutOptions),
            typeof(TabView),
            LayoutOptions.Center
        );
}

Файл: MPowerKit.TabView\TabViewHeaderItem.cs
using System.Runtime.CompilerServices;

namespace MPowerKit.TabView;

public class TabViewHeaderItem : Grid
{
    protected readonly DataTemplate StringTemplate = new(() =>
    {
        var lbl = new Label()
        {
            VerticalOptions = LayoutOptions.Center,
            HorizontalOptions = LayoutOptions.Center,
            VerticalTextAlignment = TextAlignment.Center,
            HorizontalTextAlignment = TextAlignment.Center
        };
        lbl.SetBinding(Label.TextProperty, ".");
        lbl.SetBinding(Label.TextColorProperty, new Binding(TabView.HeaderTextColorProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        lbl.SetBinding(Label.FontFamilyProperty, new Binding(TabView.HeaderFontFamilyProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        lbl.SetBinding(Label.FontSizeProperty, new Binding(TabView.HeaderFontSizeProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        lbl.SetBinding(Label.FontAttributesProperty, new Binding(TabView.HeaderFontAttributesProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        return new ContentView()
        {
            Content = lbl,
            VerticalOptions = LayoutOptions.Fill,
            HorizontalOptions = LayoutOptions.Fill,
            Padding = new Thickness(20, 10)
        };
    });

    protected View? SelectedView;
    protected View? UnselectedView;

    public TabViewHeaderItem()
    {
        var tap = new TapGestureRecognizer();
        tap.Tapped += Tap_Tapped;
        GestureRecognizers.Add(tap);

        SetBinding(SelectedContentTemplateProperty, new Binding(TabView.SelectedHeaderTemplateProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        SetBinding(ContentTemplateProperty, new Binding(TabView.HeaderTemplateProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        SetBinding(HideWhenDisabledProperty, new Binding(TabView.HideTabsWhenDisabledProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
		SetBinding(BackgroundColorProperty, new Binding(TabView.HeaderBackgroundColorProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));

        // Привяжем VerticalOptions и HorizontalOptions к новым свойствам TabView
        SetBinding(VerticalOptionsProperty, new Binding(
            nameof(TabView.HeaderItemVerticalOptions),
            source: RelativeBindingSource.TemplatedParent));

        SetBinding(HorizontalOptionsProperty, new Binding(
            nameof(TabView.HeaderItemHorizontalOptions),
            source: RelativeBindingSource.TemplatedParent));

    }

    private void Tap_Tapped(object? sender, EventArgs e)
    {
        if (!IsEnabled) return;

        if (!IsSelected) IsSelected = true;
    }

    protected override void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        base.OnPropertyChanged(propertyName);

        if (propertyName == HideWhenDisabledProperty.PropertyName)
        {
            IsVisible = !HideWhenDisabled || IsEnabled;
            return;
        }

        if (propertyName == HeaderContentProperty.PropertyName && HeaderContent is View content)
        {
            Children.Clear();
            Children.Add(content);
        }

        if (HeaderContent is View) return;

        else if (propertyName == IsSelectedProperty.PropertyName)
        {
            SetBinding(View.BackgroundColorProperty, new Binding(IsSelected
                ? TabView.SelectedHeaderBackgroundColorProperty.PropertyName
                : TabView.HeaderBackgroundColorProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        }
        else if (propertyName == HeaderContentProperty.PropertyName
            || propertyName == SelectedContentTemplateProperty.PropertyName
            || propertyName == ContentTemplateProperty.PropertyName)
        {
            InitContent();
        }
    }

    public virtual void InitContent()
    {
        var unselectedTemplate = ContentTemplate != null
            ? (ContentTemplate is DataTemplateSelector selectorU ? selectorU.SelectTemplate(HeaderContent, null) : ContentTemplate)
            : StringTemplate;

        var selectedTemplate = SelectedContentTemplate != null
            ? (SelectedContentTemplate is DataTemplateSelector selectorS ? selectorS.SelectTemplate(HeaderContent, null) : SelectedContentTemplate)
            : unselectedTemplate;

        var context = HeaderContent;
        context ??= "Empty Header";

        SelectedView = selectedTemplate.CreateContent() as View;
        SelectedView!.BindingContext = selectedTemplate == StringTemplate ? context.ToString() : context;

        UnselectedView = unselectedTemplate.CreateContent() as View;
        UnselectedView!.BindingContext = unselectedTemplate == StringTemplate ? context.ToString() : context;

        SelectedView.SetBinding(View.IsVisibleProperty, new Binding(IsSelectedProperty.PropertyName, source: this));
        UnselectedView.SetBinding(View.IsVisibleProperty, new Binding(IsSelectedProperty.PropertyName, source: this, converter: new InverseBooleanConverter()));

        Children.Clear();
        Children.Add(SelectedView);
        Children.Add(UnselectedView);
    }

    #region IsSelected
    public bool IsSelected
    {
        get { return (bool)GetValue(IsSelectedProperty); }
        set { SetValue(IsSelectedProperty, value); }
    }

    public static readonly BindableProperty IsSelectedProperty =
        BindableProperty.Create(
            nameof(IsSelected),
            typeof(bool),
            typeof(TabViewHeaderItem)
            );
    #endregion

    #region HeaderContent
    public object HeaderContent
    {
        get { return (object)GetValue(HeaderContentProperty); }
        set { SetValue(HeaderContentProperty, value); }
    }

    public static readonly BindableProperty HeaderContentProperty =
        BindableProperty.Create(
            nameof(HeaderContent),
            typeof(object),
            typeof(TabViewHeaderItem)
            );
    #endregion

    #region SelectedContentTemplate
    public DataTemplate SelectedContentTemplate
    {
        get { return (DataTemplate)GetValue(SelectedContentTemplateProperty); }
        set { SetValue(SelectedContentTemplateProperty, value); }
    }

    public static readonly BindableProperty SelectedContentTemplateProperty =
        BindableProperty.Create(
            nameof(SelectedContentTemplate),
            typeof(DataTemplate),
            typeof(TabViewHeaderItem)
            );
    #endregion

    #region ContentTemplate
    public DataTemplate ContentTemplate
    {
        get { return (DataTemplate)GetValue(ContentTemplateProperty); }
        set { SetValue(ContentTemplateProperty, value); }
    }

    public static readonly BindableProperty ContentTemplateProperty =
        BindableProperty.Create(
            nameof(ContentTemplate),
            typeof(DataTemplate),
            typeof(TabViewHeaderItem)
            );
    #endregion

    #region HideWhenDisabled
    public bool HideWhenDisabled
    {
        get { return (bool)GetValue(HideWhenDisabledProperty); }
        set { SetValue(HideWhenDisabledProperty, value); }
    }

    public static readonly BindableProperty HideWhenDisabledProperty =
        BindableProperty.Create(
            nameof(HideWhenDisabled),
            typeof(bool),
            typeof(TabViewHeaderItem),
            true
            );
    #endregion
}

Файл: MPowerKit.TabView\TabViewItem.cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace MPowerKit.TabView;

public class TabViewItem : ContentView
{
    public TabViewHeaderItem TabViewHeaderItem { get; protected set; } = [];

    public TabViewItem()
    {
        TabViewHeaderItem.PropertyChanged += TabViewHeaderItem_PropertyChanged;

        SetBinding(IsVisibleProperty, new Binding(IsSelectedProperty.PropertyName, source: this));
        TabViewHeaderItem.SetBinding(View.IsEnabledProperty, new Binding(IsEnabledProperty.PropertyName, mode: BindingMode.TwoWay, source: this));
        TabViewHeaderItem.SetBinding(TabViewHeaderItem.HeaderContentProperty, new Binding(HeaderProperty.PropertyName, source: this));
        TabViewHeaderItem.SetBinding(Grid.ColumnProperty, new Binding(ColumnProperty.PropertyName, source: this));
        TabViewHeaderItem.SetBinding(Grid.RowProperty, new Binding(RowProperty.PropertyName, source: this));
    }

    private void TabViewHeaderItem_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == TabViewHeaderItem.IsSelectedProperty.PropertyName)
        {
            IsSelected = TabViewHeaderItem.IsSelected;
        }
    }

    protected override void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        base.OnPropertyChanged(propertyName);

        if (propertyName == IsEnabledProperty.PropertyName
            || propertyName == IsSelectedProperty.PropertyName
            && !IsEnabled && IsSelected)
        {
            IsSelected = false;
        }

        if (propertyName == IsSelectedProperty.PropertyName)
        {
            TabViewHeaderItem.IsSelected = IsSelected;
        }
    }

    #region IsSelected
    public bool IsSelected
    {
        get { return (bool)GetValue(IsSelectedProperty); }
        set { SetValue(IsSelectedProperty, value); }
    }

    public static readonly BindableProperty IsSelectedProperty =
        BindableProperty.Create(
            nameof(IsSelected),
            typeof(bool),
            typeof(TabViewItem)
            );
    #endregion

    #region Header
    public object Header
    {
        get { return (object)GetValue(HeaderProperty); }
        set { SetValue(HeaderProperty, value); }
    }

    public static readonly BindableProperty HeaderProperty =
        BindableProperty.Create(
            nameof(Header),
            typeof(object),
            typeof(TabViewItem)
            );
    #endregion

    #region Column
    public int Column
    {
        get { return (int)GetValue(ColumnProperty); }
        set { SetValue(ColumnProperty, value); }
    }

    public static readonly BindableProperty ColumnProperty =
        BindableProperty.Create(
            nameof(Column),
            typeof(int),
            typeof(TabViewItem)
            );
    #endregion

    #region Row
    public int Row
    {
        get { return (int)GetValue(RowProperty); }
        set { SetValue(RowProperty, value); }
    }

    public static readonly BindableProperty RowProperty =
        BindableProperty.Create(
            nameof(Row),
            typeof(int),
            typeof(TabViewItem)
            );
    #endregion
}

Файл: MPowerKit.TabView\TabViewStyle.xaml
<?xml version="1.0" encoding="utf-8" ?>
<ResourceDictionary x:Class="MPowerKit.TabView.TabViewStyle"
                    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
                    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
                    xmlns:controls="clr-namespace:MPowerKit.TabView">

    <Style TargetType="controls:TabView">
        <Setter Property="Padding"
                Value="0" />
        <Setter Property="Margin"
                Value="0" />
        <Setter Property="ControlTemplate">
            <Setter.Value>
                <ControlTemplate>
                    <Grid ColumnSpacing="0"
                          RowSpacing="0">
                        <Grid.Triggers>
                            <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="Grid"
                                         Value="Top">
                                <Setter Property="RowDefinitions"
                                        Value="Auto,*" />
                                <Setter Property="ColumnDefinitions"
                                        Value="*" />
                            </DataTrigger>
                            <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="Grid"
                                         Value="Bottom">
                                <Setter Property="RowDefinitions"
                                        Value="*,Auto" />
                                <Setter Property="ColumnDefinitions"
                                        Value="*" />
                            </DataTrigger>
                            <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="Grid"
                                         Value="Left">
                                <Setter Property="RowDefinitions"
                                        Value="*" />
                                <Setter Property="ColumnDefinitions"
                                        Value="Auto,*" />
                            </DataTrigger>
                            <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="Grid"
                                         Value="Right">
                                <Setter Property="RowDefinitions"
                                        Value="*" />
                                <Setter Property="ColumnDefinitions"
                                        Value="*,Auto" />
                            </DataTrigger>
                        </Grid.Triggers>
                        <ScrollView x:Name="PART_HeadersScrollView"
                                    Margin="{TemplateBinding Padding}"
                                    BackgroundColor="{TemplateBinding HeaderBarBackgroundColor}"
                                    HorizontalOptions="Fill"
                                    HorizontalScrollBarVisibility="Never"
                                    VerticalOptions="Fill"
                                    VerticalScrollBarVisibility="Never">
                            <ScrollView.Triggers>
                                <!-- Горизонтальная шапка сверху -->
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="ScrollView"
                                         Value="Top">
                                    <Setter Property="Orientation" Value="Horizontal" />
                                    <Setter Property="Grid.Row" Value="0" />
                                    <Setter Property="Grid.Column" Value="0" />
                                    <Setter Property="HeightRequest" Value="{TemplateBinding HeaderHeightRequest}" />
                                </DataTrigger>

                                <!-- Горизонтальная шапка снизу -->
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="ScrollView"
                                         Value="Bottom">
                                    <Setter Property="Orientation" Value="Horizontal" />
                                    <Setter Property="Grid.Row" Value="1" />
                                    <Setter Property="Grid.Column" Value="0" />
                                    <Setter Property="HeightRequest" Value="{TemplateBinding HeaderHeightRequest}" />
                                </DataTrigger>

                                <!-- Вертикальная панель слева -->
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="ScrollView"
                                         Value="Left">
                                    <Setter Property="Orientation" Value="Vertical" />
                                    <Setter Property="Grid.Row" Value="0" />
                                    <Setter Property="Grid.Column" Value="0" />
                                    <Setter Property="WidthRequest" Value="{TemplateBinding HeaderHeightRequest}" />
                                </DataTrigger>

                                <!-- Вертикальная панель справа -->
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="ScrollView"
                                         Value="Right">
                                    <Setter Property="Orientation" Value="Vertical" />
                                    <Setter Property="Grid.Row" Value="0" />
                                    <Setter Property="Grid.Column" Value="1" />
                                    <Setter Property="WidthRequest" Value="{TemplateBinding HeaderHeightRequest}" />
                                </DataTrigger>
                            </ScrollView.Triggers>

                            <controls:ItemsPresenter />
                        </ScrollView>
                        <Grid x:Name="PART_ContentContainer"
                              Grid.Row="1"
                              Margin="{TemplateBinding Padding}"
                              BackgroundColor="{TemplateBinding ContentBackgroundColor}">
                            <Grid.Triggers>
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                             TargetType="Grid"
                                             Value="Top">
                                    <Setter Property="Grid.Row"
                                            Value="1" />
                                    <Setter Property="Grid.Column"
                                            Value="0" />
                                </DataTrigger>
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                             TargetType="Grid"
                                             Value="Bottom">
                                    <Setter Property="Grid.Row"
                                            Value="0" />
                                    <Setter Property="Grid.Column"
                                            Value="0" />
                                </DataTrigger>
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                             TargetType="Grid"
                                             Value="Left">
                                    <Setter Property="Grid.Row"
                                            Value="0" />
                                    <Setter Property="Grid.Column"
                                            Value="1" />
                                </DataTrigger>
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                             TargetType="Grid"
                                             Value="Right">
                                    <Setter Property="Grid.Row"
                                            Value="0" />
                                    <Setter Property="Grid.Column"
                                            Value="0" />
                                </DataTrigger>
                            </Grid.Triggers>
                        </Grid>
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>

Файл: MPowerKit.TabView\TabViewStyle.xaml.cs
namespace MPowerKit.TabView;

public partial class TabViewStyle
{
    public TabViewStyle()
    {
        InitializeComponent();
    }
}

Файл: PipeProfileAppMaui\App.xaml
<?xml version = "1.0" encoding = "UTF-8" ?>
<Application xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:conv="clr-namespace:PipeProfileAppMaui.Converters"
             xmlns:local="clr-namespace:PipeProfileAppMaui"
             xmlns:viewModels="clr-namespace:PipeProfileAppMaui.ViewModels"
             xmlns:tab="clr-namespace:MPowerKit.TabView;assembly=MPowerKit.TabView"
             x:Class="PipeProfileAppMaui.App">
    <Application.Resources>
        <ResourceDictionary>
            <!-- регистрируем конвертер -->
            <conv:BoolToStateConverter x:Key="BoolToStateConverter" />
            <conv:SelectedTabBackgroundConverter x:Key="SelectedTabBackgroundConverter"/>
            <conv:HeaderEqualsConverter x:Key="HeaderEqualsConverter"/>
            <viewModels:ViewModelLocator x:Key="Locator"/>

            <ResourceDictionary.MergedDictionaries>
                <tab:TabViewStyle />

                <ResourceDictionary Source="Resources/Styles/Colors.xaml" />
                <ResourceDictionary Source="Resources/Styles/Styles.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>


Файл: PipeProfileAppMaui\App.xaml.cs
using Microsoft.Maui.Controls;
using Microsoft.Maui.Devices.Sensors;
using PipeProfileAppMaui.ViewModels;
using System.Diagnostics;

namespace PipeProfileAppMaui
{
    public partial class App : Application
    {
        // 1) Статический локатор, чтобы к нему можно было обратиться из XAML
        public App()
        {
            InitializeComponent();
            MainPage = new AppShell();
        }
    }
}

Файл: PipeProfileAppMaui\AppShell.xaml
<?xml version="1.0" encoding="utf-8"?>
<Shell
  x:Class="PipeProfileAppMaui.AppShell"
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  xmlns:local="clr-namespace:PipeProfileAppMaui"
  Shell.FlyoutBehavior="Disabled"
  Shell.NavBarIsVisible="True">

    <!-- Единственный ShellContent, отображает MainPage -->
    <ShellContent
    Title="Профиль"
    Route="MainPage"
    ContentTemplate="{DataTemplate local:MainPage}" />

</Shell>

Файл: PipeProfileAppMaui\AppShell.xaml.cs
namespace PipeProfileAppMaui
{
    public partial class AppShell : Shell
    {
        public AppShell()
        {
            InitializeComponent();
        }
    }
}


Файл: PipeProfileAppMaui\MainPage.xaml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage
    x:Class="PipeProfileAppMaui.MainPage"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:controls="clr-namespace:PipeProfileAppMaui.Controls"
    xmlns:viewModels="clr-namespace:PipeProfileAppMaui.ViewModels"
    Title="Профиль"
    BindingContext="{Binding Source={StaticResource Locator}, Path=MainViewModel}">

    <Grid RowDefinitions="Auto,*" ColumnDefinitions="300,*">

            <!-- 1) Ribbon -->
            <controls:RibbonView
              Grid.Row="0" Grid.ColumnSpan="2"/>

            <!-- 2.1) Панель для точек -->
            <!--  Боковые вкладки -->
            <controls:SideTabView
              Grid.Row="1"
              Grid.Column="0"
              HorizontalOptions="Fill"
              VerticalOptions="Fill" />

            <!-- 2.2) Canvas-профиль -->
            <controls:PipeProfileView
              Grid.Row="1"
              Grid.Column="1"
              ViewModel="{Binding}" />

        </Grid>
</ContentPage>

Файл: PipeProfileAppMaui\MainPage.xaml.cs
using Microsoft.Maui.Controls;
using SkiaSharp;
using SkiaSharp.Views.Maui;
using SkiaSharp.Views.Maui.Controls;
using PipeProfileAppMaui.ViewModels;
using PipeProfileAppMaui.Services;
using System.Diagnostics;

namespace PipeProfileAppMaui;

public partial class MainPage : ContentPage
{
    public MainPage()           // ← **этот** конструктор Shell будет вызывать
    {
        InitializeComponent();
    }
}

Файл: PipeProfileAppMaui\MauiProgram.cs
using Microsoft.Extensions.DependencyInjection;
using PipeProfileAppMaui.Services;
using PipeProfileAppMaui.ViewModels;
using CommunityToolkit.Maui;
using SkiaSharp.Views.Maui.Controls.Hosting;
using UraniumUI;

namespace PipeProfileAppMaui
{
    public static class MauiProgram
    {
        public static MauiApp CreateMauiApp()
        {
            var builder = MauiApp.CreateBuilder();
            builder
                .UseMauiApp<App>()
                .UseSkiaSharp()  // Регистрируем SkiaSharp для MAUI
                .UseMauiCommunityToolkit() // Инициализация CommunityToolkit.Maui
                .ConfigureFonts(fonts =>
                {
                    fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
                    fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
                    fonts.AddFont("gost-type-au.ttf", "GOST_Type_AU");
                });

            //builder.Services.AddSingleton<PipeProfileRenderer>();
            //builder.Services.AddSingleton<MainViewModel>();

            //builder.Services.AddSingleton<ProfileRenderer>();
            builder.Services.AddSingleton<MainPage>();
            builder.Services.AddSingleton<AppShell>();

            return builder.Build();
        }
    }
}

Файл: PipeProfileAppMaui\PipeProfileAppMaui.csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFrameworks>;net8.0-android34.0</TargetFrameworks>
		<TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(TargetFrameworks);net8.0-windows10.0.19041.0</TargetFrameworks>
		<!-- Uncomment to also build the tizen app. You will need to install tizen by following this: https://github.com/Samsung/Tizen.NET -->
		<!-- <TargetFrameworks>$(TargetFrameworks);net8.0-tizen</TargetFrameworks> -->

		<!-- Note for MacCatalyst:
		The default runtime is maccatalyst-x64, except in Release config, in which case the default is maccatalyst-x64;maccatalyst-arm64.
		When specifying both architectures, use the plural <RuntimeIdentifiers> instead of the singular <RuntimeIdentifier>.
		The Mac App Store will NOT accept apps with ONLY maccatalyst-arm64 indicated;
		either BOTH runtimes must be indicated or ONLY macatalyst-x64. -->
		<!-- For example: <RuntimeIdentifiers>maccatalyst-x64;maccatalyst-arm64</RuntimeIdentifiers> -->

		<OutputType>Exe</OutputType>
		<RootNamespace>PipeProfileAppMaui</RootNamespace>
		<UseMaui>true</UseMaui>
		<SingleProject>true</SingleProject>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>

		<!-- Display name -->
		<ApplicationTitle>PipeProfileAppMaui</ApplicationTitle>

		<!-- App Identifier -->
		<ApplicationId>com.companyname.pipeprofileappmaui</ApplicationId>

		<!-- Versions -->
		<ApplicationDisplayVersion>1.0</ApplicationDisplayVersion>
		<ApplicationVersion>1</ApplicationVersion>

		<SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'ios'">11.0</SupportedOSPlatformVersion>
		<SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'maccatalyst'">13.1</SupportedOSPlatformVersion>
		<SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'android'">30.0</SupportedOSPlatformVersion>
		<SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'windows'">10.0.17763.0</SupportedOSPlatformVersion>
		<TargetPlatformMinVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'windows'">10.0.17763.0</TargetPlatformMinVersion>
		<SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'tizen'">6.5</SupportedOSPlatformVersion>
		<WindowsPackageType>None</WindowsPackageType>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)|$(TargetFramework)|$(Platform)'=='Release|net8.0-android34.0|AnyCPU'">
	  <AndroidPackageFormat>apk</AndroidPackageFormat>
	  <RunAOTCompilation>False</RunAOTCompilation>
	</PropertyGroup>

	<ItemGroup>
		<!-- App Icon -->
		<MauiIcon Include="Resources\AppIcon\appicon.svg" ForegroundFile="Resources\AppIcon\appiconfg.svg" Color="#512BD4" />

		<!-- Splash Screen -->
		<MauiSplashScreen Include="Resources\Splash\splash.svg" Color="#512BD4" BaseSize="128,128" />

		<!-- Images -->
		<MauiImage Include="Resources\Images\*" />
		<MauiImage Update="Resources\Images\dotnet_bot.png" Resize="True" BaseSize="300,185" />
		
		<!--TabIcons-->
		<MauiImage Include="Resources\TabIcons\ground.svg" Resize="True" BaseSize="300,185" />
		<MauiImage Include="Resources\TabIcons\pipe.svg" Resize="True" BaseSize="300,185" />

		<!-- Custom Fonts -->
		<MauiFont Include="Resources\Fonts\*" />

		<!-- Raw Assets (also remove the "Resources\Raw" prefix) -->
		<MauiAsset Include="Resources\Raw\**" LogicalName="%(RecursiveDir)%(Filename)%(Extension)" />
	</ItemGroup>

	<!--<ItemGroup>
	  <Compile Remove="Controls\PipeProfileView.Init.cs" />
	</ItemGroup>

	<ItemGroup>
	  <None Include="Controls\PipeProfileView.Init.cs" />
	</ItemGroup>-->

	<ItemGroup>
		<PackageReference Include="CommunityToolkit.Maui" Version="9.1.1" />
		<PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
		<PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="9.0.6" />
		<PackageReference Include="Microsoft.Maui.Controls" Version="$(MauiVersion)" />
		<PackageReference Include="Microsoft.Maui.Controls.Compatibility" Version="$(MauiVersion)" />
		<PackageReference Include="Microsoft.Extensions.Logging.Debug" Version="8.0.1" />
		<PackageReference Include="SkiaSharp" Version="3.119.0" />
		<PackageReference Include="SkiaSharp.Views.Maui.Controls" Version="3.119.0" />
		<PackageReference Include="UraniumUI" Version="2.12.1" />
		<PackageReference Include="UraniumUI.Material" Version="2.12.1" />

		<ProjectReference Include="..\MPowerKit.TabView\MPowerKit.TabView.csproj" />
	</ItemGroup>

	<ItemGroup>
	  <Compile Update="Controls\RibbonView.xaml.cs">
	    <DependentUpon>RibbonView.xaml</DependentUpon>
	  </Compile>
	</ItemGroup>

	<ItemGroup>
	  <MauiXaml Update="Controls\GroundPointsControl.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </MauiXaml>
	  <MauiXaml Update="Controls\RibbonView.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </MauiXaml>
	  <MauiXaml Update="Controls\PipePointsControl.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </MauiXaml>
	  <MauiXaml Update="Controls\PipeProfileView.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </MauiXaml>
	  <MauiXaml Update="Controls\SideTabView.xaml">
	    <Generator>MSBuild:Compile</Generator>
	  </MauiXaml>
	</ItemGroup>

</Project>


Файл: PipeProfileAppMaui\ViewModelLocator.cs
using Microsoft.Extensions.DependencyInjection;
using PipeProfileAppMaui.Services;

namespace PipeProfileAppMaui.ViewModels
{
    public class ViewModelLocator
    {
        private readonly IServiceProvider _serviceProvider;

        public ViewModelLocator()
        {
            var services = new ServiceCollection();

            // Сначала MainViewModel
            services.AddSingleton<MainViewModel>();

            //// Затем RibbonViewModel через фабрику, чтобы DI знал про зависимость
            //services.AddSingleton<RibbonViewModel>(sp =>
            //{
            //    var mainVm = sp.GetRequiredService<MainViewModel>();
            //    return new RibbonViewModel(mainVm);
            //});

            //services.AddSingleton<GroundViewModel>();
            //services.AddSingleton<PipeViewModel>();
            //services.AddSingleton<PipeProfileRenderer>();
            //services.AddSingleton<RibbonViewModel>();
           _serviceProvider = services.BuildServiceProvider();
        }

        public MainViewModel MainViewModel => _serviceProvider.GetRequiredService<MainViewModel>();
        //public GroundViewModel GroundViewModel => _serviceProvider.GetRequiredService<GroundViewModel>();
        //public PipeViewModel PipeViewModel => _serviceProvider.GetRequiredService<PipeViewModel>();
        //public RibbonViewModel RibbonViewModel => _serviceProvider.GetRequiredService<RibbonViewModel>();
    }
}

Файл: PipeProfileAppMaui\Controls\EditorManager.cs
using System;
using System.Linq;
using Microsoft.Maui.Controls;
using PipeProfileAppMaui.Models;
using SkiaSharp;
using SkiaSharp.Views.Maui;
using Microsoft.Maui.Layouts;
using SkiaSharp.Views.Maui.Controls;
using PipeProfileAppMaui.ViewModels;

namespace PipeProfileAppMaui.Controls
{
    /// <summary>
    /// Управляет созданием, позиционированием и закрытием редактора штампа.
    /// </summary>
    public class EditorManager
    {
        readonly AbsoluteLayout _root;
        readonly SKCanvasView _canvas;
        readonly Stamp _stamp;
        MainViewModel _vm;
        readonly Action _invalidate;

        Editor _editor;
        int _row, _col;
        SKRect _cellWorld;
        float _dipToPixX = 1, _dipToPixY = 1;

        public float DipToPixX => _dipToPixX;
        public float DipToPixY => _dipToPixY;

        public EditorManager(
            AbsoluteLayout root,
            SKCanvasView canvas,
            Stamp stamp,
            MainViewModel vm,
            Action invalidateSurface)
        {
            _root = root;
            _canvas = canvas;
            _stamp = stamp;
            _vm = vm;
            _invalidate = invalidateSurface;

            // Пересчитать DPI → пиксели при изменении размера
            _canvas.SizeChanged += (_, _) => UpdateDipToPix();
        }

        /// <summary>
        /// Перевычисляет коэффициенты DIP→Pixel.
        /// </summary>
        /// 

        public void SetViewModel(MainViewModel vm)
        {
            _vm = vm ?? throw new ArgumentNullException(nameof(vm));
        }

        public void UpdateDipToPix()
        {
            var sz = _canvas.CanvasSize;
            if (_canvas.Width > 0 && _canvas.Height > 0)
            {
                _dipToPixX = sz.Width / (float)_canvas.Width;
                _dipToPixY = sz.Height / (float)_canvas.Height;
            }
        }

        /// <summary>
        /// Обрабатывает касание на CanvasView.
        /// Вызывает ShowEditor или EndEdit по необходимости.
        /// </summary>
        public void HandleTouch(SKPoint locationInDIP, SKRect stampRect)
        {
            // 1) Переводим DIP → пиксели канвы
            var pix = new SKPoint(locationInDIP.X * _dipToPixX,
                                  locationInDIP.Y * _dipToPixY);

            // 2) Преобразуем в мировые координаты
            var world = _vm.Transform.InverseMatrix.MapPoint(pix);

            // 3) Если редактор открыт и тап вне текущей ячейки — закрыть
            if (_editor != null && !_cellWorld.Contains(world))
            {
                EndEdit();
                return;
            }

            // 4) Проверяем попадание в штамп
            var hit = _stamp.HitTest(world, stampRect);
            if (hit.HasValue)
            {
                ShowEditor(hit.Value.row, hit.Value.col, stampRect);
            }
        }
        /// <summary>
        /// Открывает Editor над ячейкой (row,col).
        /// </summary>
        void ShowEditor(int row, int col, SKRect stampRect)
        {
            // Закрываем предыдущий
            if (_editor != null)
                EndEdit();

            _row = row;
            _col = col;
            _cellWorld = _stamp.GetCellRect(row, col, stampRect);

            // Создаем Editor и биндим текст напрямую к VM
            var cellVm = _vm.StampCells[row][col];
            var editor = new Editor
            {
                BackgroundColor = Colors.CadetBlue,
                HorizontalTextAlignment = TextAlignment.Center,
                VerticalOptions = LayoutOptions.Fill,
                HorizontalOptions = LayoutOptions.Fill
            };
            editor.SetBinding(Editor.TextProperty,
                new Binding(nameof(StampCell.Text),
                            source: cellVm,
                            mode: BindingMode.TwoWay));



            // Закрытие по потере фокуса
            editor.Unfocused += (_, __) => EndEdit();

            _editor = editor;

            editor.AutoSize = EditorAutoSizeOption.TextChanges;

            PositionEditor();

            AbsoluteLayout.SetLayoutFlags(editor, AbsoluteLayoutFlags.None);
            _root.Children.Add(editor);
            editor.Focus();
        }

        /// <summary>
        /// Переставляет Editor по текущему Pan/Zoom.
        /// </summary>
        public void PositionEditor()
        {
            if (_editor == null)
                return;

            // world → canvas → DIP
            var p0 = _vm.Transform.Matrix.MapPoint(_cellWorld.Left, _cellWorld.Top);
            var p1 = _vm.Transform.Matrix.MapPoint(_cellWorld.Right, _cellWorld.Bottom);

            double x = p0.X / _dipToPixX;
            double y = p0.Y / _dipToPixY;
            double w = (p1.X - p0.X) / _dipToPixX;
            double h = (p1.Y - p0.Y) / _dipToPixY;

            AbsoluteLayout.SetLayoutBounds(_editor, new Rect(x, y, w, h));
        }

        /// <summary>
        /// Закрывает Editor, не трогая модель — двусторонний биндинг уже записал текст.
        /// </summary>
        public void EndEdit()
        {
            if (_editor == null)
                return;

            _root.Children.Remove(_editor);
            _editor = null;

            // перерисовать штамп
            _invalidate();
        }
    }
}

Файл: PipeProfileAppMaui\Controls\GroundPointsControl.xaml
<?xml version="1.0" encoding="utf-8" ?>
<ContentView
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    x:Class="PipeProfileAppMaui.Controls.GroundPointsControl"
    x:Name="root">

    <VerticalStackLayout Padding="10" Spacing="5">
        <!-- Заголовок -->
        <Label Text="Точки грунта"
           FontAttributes="Bold" />

        <!-- Список точек -->
        <CollectionView ItemsSource="{Binding GroundPoints, Source={x:Reference root}}">
            <CollectionView.ItemTemplate>
                <DataTemplate>
                    <Grid ColumnDefinitions="40,*,*,Auto,Auto,Auto" Padding="2">
                        <Label   Grid.Column="0"
                 Text="{Binding Index}"
                 VerticalOptions="Center" />

                        <Entry   Grid.Column="1"
                 Text="{Binding Distance_m, Mode=TwoWay}"
                 Keyboard="Numeric" />

                        <Entry   Grid.Column="2"
                 Text="{Binding Elevation_cm, Mode=TwoWay}"
                 Keyboard="Numeric" />

                        <Button  Grid.Column="3"
                 Text="+"
                 WidthRequest="30"
                 Command="{Binding IncreaseDistanceCommand,   Source={x:Reference root}}"
                 CommandParameter="{Binding .}" />

                        <Button  Grid.Column="4"
                 Text="−"
                 WidthRequest="30"
                 Command="{Binding DecreaseDistanceCommand,   Source={x:Reference root}}"
                 CommandParameter="{Binding .}" />

                        <Button  Grid.Column="5"
                 Text="×"
                 WidthRequest="60"
                 Command="{Binding RemovePointCommand,        Source={x:Reference root}}"
                 CommandParameter="{Binding .}" />
                    </Grid>
                </DataTemplate>
            </CollectionView.ItemTemplate>
        </CollectionView>
        <!-- Добавить новую точку -->
        <Button Text="Добавить точку"
            Command="{Binding AddPointCommand, Source={x:Reference root}}" />
    </VerticalStackLayout>
</ContentView>

Файл: PipeProfileAppMaui\Controls\GroundPointsControl.xaml.cs
using System.Collections.ObjectModel;
using System.Windows.Input;                 // ICommand
using Microsoft.Maui.Controls;
using PipeProfileAppMaui.Models;

namespace PipeProfileAppMaui.Controls
{
    public partial class GroundPointsControl : ContentView
    {
        // 1) ��������� ����� � BindableProperty
        public static readonly BindableProperty GroundPointsProperty =
            BindableProperty.Create(
                nameof(GroundPoints),
                typeof(ObservableCollection<GroundPoint>),
                typeof(GroundPointsControl),
                new ObservableCollection<GroundPoint>());

        public ObservableCollection<GroundPoint> GroundPoints
        {
            get => (ObservableCollection<GroundPoint>)GetValue(GroundPointsProperty);
            set => SetValue(GroundPointsProperty, value);
        }

        // 2) ������� ��������� �����
        public static readonly BindableProperty AddPointCommandProperty =
            BindableProperty.Create(
                nameof(AddPointCommand),
                typeof(ICommand),
                typeof(GroundPointsControl));

        public ICommand AddPointCommand
        {
            get => (ICommand)GetValue(AddPointCommandProperty);
            set => SetValue(AddPointCommandProperty, value);
        }

        // 3) ������� �������� �����
        public static readonly BindableProperty RemovePointCommandProperty =
            BindableProperty.Create(
                nameof(RemovePointCommand),
                typeof(ICommand),
                typeof(GroundPointsControl));

        public ICommand RemovePointCommand
        {
            get => (ICommand)GetValue(RemovePointCommandProperty);
            set => SetValue(RemovePointCommandProperty, value);
        }

        // 4) ������� ���������� ����������
        public static readonly BindableProperty IncreaseDistanceCommandProperty =
            BindableProperty.Create(
                nameof(IncreaseDistanceCommand),
                typeof(ICommand),
                typeof(GroundPointsControl));

        public ICommand IncreaseDistanceCommand
        {
            get => (ICommand)GetValue(IncreaseDistanceCommandProperty);
            set => SetValue(IncreaseDistanceCommandProperty, value);
        }

        // 5) ������� ���������� ����������
        public static readonly BindableProperty DecreaseDistanceCommandProperty =
            BindableProperty.Create(
                nameof(DecreaseDistanceCommand),
                typeof(ICommand),
                typeof(GroundPointsControl));

        public ICommand DecreaseDistanceCommand
        {
            get => (ICommand)GetValue(DecreaseDistanceCommandProperty);
            set => SetValue(DecreaseDistanceCommandProperty, value);
        }

        public GroundPointsControl()
        {
            InitializeComponent();
        }
    }
}

Файл: PipeProfileAppMaui\Controls\PipePointsControl.xaml
<?xml version="1.0" encoding="utf-8" ?>
<ContentView
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    x:Class="PipeProfileAppMaui.Controls.PipePointsControl"
    x:Name="root">

    <VerticalStackLayout Padding="10" Spacing="5">
        <!-- Заголовок -->
        <Label Text="Точки трубы" FontAttributes="Bold" />

        <!-- Список точек трубы -->
        <CollectionView ItemsSource="{Binding PipePoints, Source={x:Reference root}}">
            <CollectionView.ItemTemplate>
                <DataTemplate>
                    <Grid ColumnDefinitions="40,*,*,Auto,Auto,Auto" Padding="2">
                        <!-- Номер -->
                        <Label Grid.Column="0"
                   Text="{Binding Index}"
                   VerticalOptions="Center" />

                        <!-- Расстояние, м -->
                        <Entry Grid.Column="1"
                   Text="{Binding Distance_m, Mode=TwoWay}"
                   Keyboard="Numeric" />

                        <!-- Глубина, см -->
                        <Entry Grid.Column="2"
                   Text="{Binding Depth_cm, Mode=TwoWay}"
                   Keyboard="Numeric" />

                        <!-- Увеличить расстояние -->
                        <Button Grid.Column="3"
                    Text="+"
                    WidthRequest="30"
                    Command="{Binding IncreaseDistanceCommand, Source={x:Reference root}}"
                    CommandParameter="{Binding .}" />

                        <!-- Уменьшить расстояние -->
                        <Button Grid.Column="4"
                    Text="−"
                    WidthRequest="30"
                    Command="{Binding DecreaseDistanceCommand, Source={x:Reference root}}"
                    CommandParameter="{Binding .}" />

                        <!-- Удалить точку -->
                        <Button Grid.Column="5"
                    Text="×"
                    WidthRequest="60"
                    Command="{Binding RemovePointCommand, Source={x:Reference root}}"
                    CommandParameter="{Binding .}" />
                    </Grid>
                </DataTemplate>
            </CollectionView.ItemTemplate>
        </CollectionView>

        <!-- Кнопка «Добавить точку» -->
        <Button Text="Добавить точку"
            Command="{Binding AddPointCommand, Source={x:Reference root}}" />
    </VerticalStackLayout>
</ContentView>

Файл: PipeProfileAppMaui\Controls\PipePointsControl.xaml.cs
using System.Collections.ObjectModel;
using System.Windows.Input;
using Microsoft.Maui.Controls;
using PipeProfileAppMaui.Models;

namespace PipeProfileAppMaui.Controls
{
    public partial class PipePointsControl : ContentView
    {
        // 1) ��������� ����� �����
        public static readonly BindableProperty PipePointsProperty =
            BindableProperty.Create(
                nameof(PipePoints),
                typeof(ObservableCollection<PipePoint>),
                typeof(PipePointsControl),
                new ObservableCollection<PipePoint>());

        public ObservableCollection<PipePoint> PipePoints
        {
            get => (ObservableCollection<PipePoint>)GetValue(PipePointsProperty);
            set => SetValue(PipePointsProperty, value);
        }

        // 2) ������� ��������� �����
        public static readonly BindableProperty AddPointCommandProperty =
            BindableProperty.Create(
                nameof(AddPointCommand),
                typeof(ICommand),
                typeof(PipePointsControl));

        public ICommand AddPointCommand
        {
            get => (ICommand)GetValue(AddPointCommandProperty);
            set => SetValue(AddPointCommandProperty, value);
        }

        // 3) ������� �������� �����
        public static readonly BindableProperty RemovePointCommandProperty =
            BindableProperty.Create(
                nameof(RemovePointCommand),
                typeof(ICommand),
                typeof(PipePointsControl));

        public ICommand RemovePointCommand
        {
            get => (ICommand)GetValue(RemovePointCommandProperty);
            set => SetValue(RemovePointCommandProperty, value);
        }

        // 4) ������� ���������� ����������
        public static readonly BindableProperty IncreaseDistanceCommandProperty =
            BindableProperty.Create(
                nameof(IncreaseDistanceCommand),
                typeof(ICommand),
                typeof(PipePointsControl));

        public ICommand IncreaseDistanceCommand
        {
            get => (ICommand)GetValue(IncreaseDistanceCommandProperty);
            set => SetValue(IncreaseDistanceCommandProperty, value);
        }

        // 5) ������� ���������� ����������
        public static readonly BindableProperty DecreaseDistanceCommandProperty =
            BindableProperty.Create(
                nameof(DecreaseDistanceCommand),
                typeof(ICommand),
                typeof(PipePointsControl));

        public ICommand DecreaseDistanceCommand
        {
            get => (ICommand)GetValue(DecreaseDistanceCommandProperty);
            set => SetValue(DecreaseDistanceCommandProperty, value);
        }

        public PipePointsControl()
        {
            InitializeComponent();
        }
    }
}

Файл: PipeProfileAppMaui\Controls\PipeProfileView.Drawing.cs
using PipeProfileAppMaui.Helpers;
using SkiaSharp;
using SkiaSharp.Views.Maui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PipeProfileAppMaui.Controls
{
    public partial class PipeProfileView
    {
        SKRect _profileArea;

        void OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)
        {
         var canvas = e.Surface.Canvas;
            var info = e.Info;
            canvas.Clear(SKColors.White);

            // 0) Применяем текущий Pan/Zoom ко всему рисунку
            canvas.Save();
            canvas.SetMatrix(ViewModel.Transform.Matrix);

            // 1) Letterbox-A4
            float maxW = info.Width - 2 * PageMargin;
            float maxH = info.Height - 2 * PageMargin;
            float a4Ratio = A4WidthMm / A4HeightMm;
            float canvasRatio = maxW / maxH;
            float sheetW = canvasRatio > a4Ratio ? maxH * a4Ratio : maxW;
            float sheetH = sheetW / a4Ratio;
            float left = PageMargin + (maxW - sheetW) / 2;
            float top = PageMargin + (maxH - sheetH) / 2;
            var sheetRect = new SKRect(
                left, top,
                left + sheetW, top + sheetH);

            // Градиент и рамка листа
            using var bg = new SKPaint
            {
                IsAntialias = true,
                Shader = SKShader.CreateRadialGradient(
                center: new SKPoint(info.Width / 2f, info.Height / 2f),
                radius: Math.Max(info.Width, info.Height),
                colors: new[] { 
                    SKColors.LightSteelBlue, // центр
                    SKColors.AliceBlue       // края
                              },
                colorPos: null,
                mode: SKShaderTileMode.Clamp)
            };
            canvas.Save();
            canvas.ClipRect(sheetRect, SKClipOperation.Difference);
            canvas.DrawRect(-info.Width, -info.Height, info.Width * 3, info.Height * 3, bg);
            canvas.Restore();
            using (var frame = new SKPaint
            {
                Style = SKPaintStyle.Stroke,
                Color = SKColors.Black,
                StrokeWidth = 1,
                IsAntialias = true
            })
                canvas.DrawRect(sheetRect, frame);

            // 1) Letterbox-A4
            _sheetRect = DrawingHelpers.CalculateLetterbox(
                e.Info.Size,
                PageConfig.PageMargin,
                PageConfig.A4WidthMm / PageConfig.A4HeightMm);

            // 2) ГОСТ-рамка
            float pxPerMm = _sheetRect.Width / PageConfig.A4WidthMm;
            _gostRect = new SKRect(
                _sheetRect.Left + 20f * pxPerMm,
                _sheetRect.Top + 5f * pxPerMm,
                _sheetRect.Right - 5f * pxPerMm,
                _sheetRect.Bottom - 5f * pxPerMm);

            // 2) Профильная область
            //float pxPerMm = sheetRect.Width / A4WidthMm;
            float stampH = 55f * pxPerMm;
            // 3) Профильная область внутри gostRect
            _profileArea = new SKRect(
                _gostRect.Left + PageConfig.ProfileInsetLeft * pxPerMm,
                _gostRect.Top + PageConfig.ProfileInsetTop * pxPerMm,
                _gostRect.Right - PageConfig.ProfileInsetRight * pxPerMm,
                _gostRect.Bottom - PageConfig.ProfileInsetBottom * pxPerMm);

            // ... после расчёта profileArea ...
            //_profileArea = profileArea;

            // 3) Рисуем профиль
            _renderer.Render(
                canvas,
                _profileArea,
                ViewModel.GroundVm.GroundPoints,
                ViewModel.PipeVm.PipePoints,
                ViewModel.GroundVm.InterpolateGroundElevation,
                ViewModel.ShowMarkers);

            var gostRect = new SKRect(
            sheetRect.Left + 20f * pxPerMm,
            sheetRect.Top + 5f * pxPerMm,
            sheetRect.Right - 5f * pxPerMm,
            sheetRect.Bottom - 5f * pxPerMm);


            // 3) Рисуем контур ГОСТ-рамки
            using var framePaint = new SKPaint
            {
                Style = SKPaintStyle.Stroke,
                Color = SKColors.Black,
                StrokeWidth = 1,
                IsAntialias = true
            };
            canvas.DrawRect(gostRect, framePaint);

            // Контур профиля
            canvas.DrawRect(_profileArea, framePaint);

            //canvas.DrawText("Hello world port", sheetRect.Left, sheetRect.Top, TextDrawingHelper.DefaultPaint);
            //var tempSize = TextDrawingHelper.GetTextSize("Hello world");
            //var newRect = new SKRect(sheetRect.Left, sheetRect.Top, sheetRect.Left + tempSize.Width, sheetRect.Top - tempSize.Height / 2);
            //canvas.DrawRect(newRect, framePaint);

            // 4) Рисуем штамп
            var gost = new SKRect(
                sheetRect.Left + 20f * pxPerMm,
                sheetRect.Top + 5f * pxPerMm,
                sheetRect.Right - 5f * pxPerMm,
                sheetRect.Bottom - 5f * pxPerMm);
            float stampW = 180f * pxPerMm;
            stampRect = new SKRect(
                gost.Right - stampW,
                gost.Bottom - stampH,
                gost.Right,
                gost.Bottom);
            _stamp.Draw(canvas, stampRect);

            var sheetWodthTemp = sheetRect.Left + 20f * pxPerMm - sheetRect.Right - 5f * pxPerMm;
            var distToBeg = _gostRect.Left + PageConfig.ProfileInsetLeft * pxPerMm - _gostRect.Right - PageConfig.ProfileInsetRight * pxPerMm;

            this.ViewModel.ScreenOffsetRatioDisplay = (sheetWodthTemp / distToBeg).ToString();

            canvas.Restore();       
        }
    }
}


Файл: PipeProfileAppMaui\Controls\PipeProfileView.Editor.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PipeProfileAppMaui.Controls
{
    public partial class PipeProfileView
    {
        void PositionEditor() => _editorManager.PositionEditor();
        void EndEdit() => _editorManager.EndEdit();
    }
}


Файл: PipeProfileAppMaui\Controls\PipeProfileView.Events.cs
#if WINDOWS
    using Microsoft.UI.Xaml;
    using Microsoft.UI.Xaml.Input;
#endif
using SkiaSharp;
using SkiaSharp.Views.Maui;
using SkiaSharp.Views.Maui.Controls;

namespace PipeProfileAppMaui.Controls
{
    public partial class PipeProfileView
    {
        // модельные единицы листа
        public float PanX { get; private set; } = 0;
        public float PanY { get; private set; } = 0;
        public float ZoomFactor { get; private set; } = 1;

        // baseScale и offset можно сохранить здесь (необязательно)
        public float BaseScale { get; set; }
        public float OffsetX { get; set; }
        public float OffsetY { get; set; }

        // для pan‐жеста
        float _lastPanX;
        float _lastPanY;

        void AttachNativeHandlers()
        {
            // подписываем wheel + pointer только на Windows
#if WINDOWS
            if (CanvasView.Handler?.PlatformView is UIElement ui)
            {
                ui.PointerPressed += OnPointerPressed;
                ui.PointerMoved += OnPointerMoved;
                ui.PointerReleased += OnPointerReleased;
                ui.PointerWheelChanged += OnPointerWheelChanged;
            }
#endif
        }


#if WINDOWS

        // состояние пэ́н-и-зум
        bool _isPanning;
        uint _panPointerId;
        SKPoint _lastWorld;
      private void OnEditorKeyDown(object sender, KeyRoutedEventArgs e)
        {
            if (e.Key == Windows.System.VirtualKey.Escape)
                EndEdit();
        }

        private void OnPointerPressed(object sender, PointerRoutedEventArgs e)
        {
            var ui = (UIElement)sender;
            var pt = e.GetCurrentPoint(ui);

            // 1) Нажали средней кнопкой — начинаем пан
            if (pt.Properties.IsMiddleButtonPressed)
            {
                _isPanning = true;
                _panPointerId = pt.PointerId;
                ui.CapturePointer(e.Pointer);

                // конвертим DIP→canvas→world
                var dip = new SKPoint((float)pt.Position.X, (float)pt.Position.Y);
                var pix = new SKPoint(dip.X * _editorManager.DipToPixX,
                                       dip.Y * _editorManager.DipToPixY);
                _lastWorld = ViewModel.Transform.InverseMatrix.MapPoint(pix);

                e.Handled = true;
            }
            // 2) Нажали левой — обрабатываем через EditorManager
            else if (pt.Properties.IsLeftButtonPressed)
            {
                var dip = new SKPoint(
                    (float)pt.Position.X,
                    (float)pt.Position.Y);

                _editorManager.HandleTouch(dip, stampRect);
                e.Handled = true;
            }
        }
        private void OnPointerMoved(object sender, PointerRoutedEventArgs e)
        {
            if (!_isPanning) return;
            var pt = e.GetCurrentPoint((UIElement)sender);
            if (pt.PointerId != _panPointerId) return;

            // 1) DIP → пиксели канвы
            var pixCur = new SKPoint(
              (float)pt.Position.X * _editorManager.DipToPixX,
              (float)pt.Position.Y * _editorManager.DipToPixY);

            // 2) пиксели → мировые
            var worldCur = ViewModel.Transform.InverseMatrix.MapPoint(pixCur);

            // 3) дельта в мировых
            var worldDx = worldCur.X - _lastWorld.X;
            var worldDy = worldCur.Y - _lastWorld.Y;

            // 4) переводим дельту мира в пиксели канвы
            var screenDx = worldDx * ViewModel.Transform.Zoom;
            var screenDy = worldDy * ViewModel.Transform.Zoom;

            ViewModel.Transform.PanX += screenDx;
            ViewModel.Transform.PanY += screenDy;

            // 5) запоминаем для следующего шага
            _lastWorld = worldCur;

            //ClampTransform();

            CanvasView.InvalidateSurface();
            e.Handled = true;
            PositionEditor();
        }

        private void OnPointerReleased(object sender, PointerRoutedEventArgs e)
        {
            var pt = e.GetCurrentPoint((UIElement)sender);
            if (!_isPanning || pt.PointerId != _panPointerId) return;

            _isPanning = false;
            ((UIElement)sender).ReleasePointerCapture(e.Pointer);
            e.Handled = true;
        }

        private void OnPointerWheelChanged(object sender, PointerRoutedEventArgs e)
        {
            var pt = e.GetCurrentPoint((UIElement)sender);
            float f = pt.Properties.MouseWheelDelta > 0 ? 1.1f : 0.9f;

            var pix = new SKPoint(
                (float)pt.Position.X * _editorManager.DipToPixX,
                (float)pt.Position.Y * _editorManager.DipToPixY);

            ViewModel.Transform.ZoomAt(f, pix);
            // в случае, если DPI или размер изменился
            _editorManager.UpdateDipToPix();

            _lastWorld = ViewModel.Transform.InverseMatrix.MapPoint(pix);

            //ClampTransform();

            CanvasView.InvalidateSurface();
            e.Handled = true;
            PositionEditor();
        }
#endif
        void OnPinchUpdated(object sender, PinchGestureUpdatedEventArgs e)
        {
            if (e.Status == GestureStatus.Started)
            {
                // ничего
            }
            else if (e.Status == GestureStatus.Running)
            {
                // точка фокуса в DIP
                var cx = (float)(CanvasView.Width * e.ScaleOrigin.X);
                var cy = (float)(CanvasView.Height * e.ScaleOrigin.Y);
                // в пиксели канвы
                var pivot = new SKPoint(
                    cx * _editorManager.DipToPixX,
                    cy * _editorManager.DipToPixY);

                ViewModel.Transform.ZoomAt((float)e.Scale, pivot);

                //ClampTransform();

                CanvasView.InvalidateSurface();
                _editorManager.PositionEditor();
            }
        }

        void OnPanUpdated(object sender, PanUpdatedEventArgs e)
        {
            if (e.StatusType == GestureStatus.Started)
            {
                _lastPanX = _lastPanY = 0;
            }
            else if (e.StatusType == GestureStatus.Running)
            {
                // дельта DIP
                float dxDip = (float)e.TotalX - _lastPanX;
                float dyDip = (float)e.TotalY - _lastPanY;

                _lastPanX = (float)e.TotalX;
                _lastPanY = (float)e.TotalY;

                // в пиксели канвы
                float dx = dxDip * _editorManager.DipToPixX;
                float dy = dyDip * _editorManager.DipToPixY;

                ViewModel.Transform.PanX += dx;
                ViewModel.Transform.PanY += dy;

                //ClampTransform();

                CanvasView.InvalidateSurface();
                _editorManager.PositionEditor();
            }
            else if (e.StatusType == GestureStatus.Completed ||
                     e.StatusType == GestureStatus.Canceled)
            {
                _lastPanX = _lastPanY = 0;
            }
        }

        void OnViewSizeChanged(object sender, EventArgs e)
        {
            //ViewModel?.UpdatePipeOffsetRatio();
            // новый размер view: Width, Height
            CanvasView.InvalidateSurface();   // перерисовать
        }

        void OnCanvasSizeChanged(object sender, EventArgs e)
        {
            // новый размер холста (DIP)
            this._editorManager.UpdateDipToPix();
            CanvasView.InvalidateSurface();
        }
    }
}


Файл: PipeProfileAppMaui\Controls\PipeProfileView.Init.cs
using PipeProfileAppMaui.Models;
using PipeProfileAppMaui.Services;
using SkiaSharp;
using SkiaSharp.Views.Maui;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PipeProfileAppMaui.Controls
{
public partial class PipeProfileView : ContentView
{
    //readonly ProfileRenderer _renderer;
    readonly EditorManager   _editorMgr;

        public PipeProfileView()
        {
            InitializeComponent();

            _renderer = new ProfileRenderer(this.ViewModel);

            // 1) Инициализируем ГОСТ-штамп
            _stamp = new Stamp();

            // 2) Создаём ProfileRenderer и EditorManager (VM подставится в OnViewModelChanged)
            //_renderer = new ProfileRenderer();
            _editorManager = new EditorManager(
                root: RootLayout,
                canvas: CanvasView,
                stamp: _stamp,
                vm: null,
                invalidateSurface: () => CanvasView.InvalidateSurface());

            CanvasView.HandlerChanged += (s, _) => AttachNativeHandlers();

            // Pinch — масштабирование
            var pinch = new PinchGestureRecognizer();
            pinch.PinchUpdated += OnPinchUpdated;
            CanvasView.GestureRecognizers.Add(pinch);

            // Pan — панорамирование
            var pan = new PanGestureRecognizer();
            pan.PanUpdated += OnPanUpdated;
            CanvasView.GestureRecognizers.Add(pan);

            // сразу отрисуем лист
            CanvasView.InvalidateSurface();

            // подписываемся на ресайз сцены (ContentView)
            this.SizeChanged += OnViewSizeChanged;

            // или на сам CanvasView, если нужно
            CanvasView.SizeChanged += OnCanvasSizeChanged;
        }

        private void OnCanvasTouch(object sender, SKTouchEventArgs e)
        {
            if (e.ActionType == SKTouchAction.Pressed
                    && e.MouseButton == SKMouseButton.Left)
            {
                // DIP координаты
                var dip = e.Location;

                // Текущие размеры
                float dipW = (float)CanvasView.Width;
                float dipH = (float)CanvasView.Height;
                var pixSz = CanvasView.CanvasSize;  // в пикселях

                // коэффициенты
                float kx = dipW > 0 ? pixSz.Width / dipW : 0;
                float ky = dipH > 0 ? pixSz.Height / dipH : 0;

                // конвертация
                var pix = new SKPoint(dip.X * kx, dip.Y * ky);

                // в мировые
                var world = ViewModel.Transform.InverseMatrix.MapPoint(pix);

                ViewModel.MouseX = Math.Round(dip.X, 2);
                ViewModel.MouseY = Math.Round(dip.Y, 2);
            }

            // не блокируем другие жесты
            e.Handled = false;
        }
    }
}


Файл: PipeProfileAppMaui\Controls\PipeProfileView.xaml
<ContentView
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
  xmlns:skia="clr-namespace:SkiaSharp.Views.Maui.Controls;assembly=SkiaSharp.Views.Maui.Controls"
  x:Class="PipeProfileAppMaui.Controls.PipeProfileView"
  x:Name="Root">
    <AbsoluteLayout x:Name="RootLayout">
        <skia:SKCanvasView
      x:Name="CanvasView"
      PaintSurface="OnPaintSurface"
      EnableTouchEvents="True"
      Touch="OnCanvasTouch"
      AbsoluteLayout.LayoutBounds="0,0,1,1"
      AbsoluteLayout.LayoutFlags="All"/>
    </AbsoluteLayout>
</ContentView>

Файл: PipeProfileAppMaui\Controls\PipeProfileView.xaml.cs
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Layouts;
using PipeProfileAppMaui.Helpers;
using PipeProfileAppMaui.Models;
using PipeProfileAppMaui.Services;
using PipeProfileAppMaui.ViewModels;
using SkiaSharp;
using SkiaSharp.Views.Maui;
using SkiaSharp.Views.Maui.Controls;

namespace PipeProfileAppMaui.Controls
{
    public partial class PipeProfileView : ContentView
    {
        // поле для подписки
        private MainViewModel? _subscribedVm;

        SKRect _sheetRect, _gostRect;
        // 1) VM-свойство и биндинг
        public static readonly BindableProperty ViewModelProperty =
            BindableProperty.Create(
                nameof(ViewModel),
                typeof(MainViewModel),
                typeof(PipeProfileView),
                propertyChanged: OnViewModelChanged);

        public MainViewModel ViewModel
        {
            get => (MainViewModel)GetValue(ViewModelProperty);
            set => SetValue(ViewModelProperty, value);
        }

        // 2) Сервисы и компоненты
        readonly ProfileRenderer _renderer;
        readonly EditorManager _editorManager;
        readonly Stamp _stamp;
        SKRect stampRect;

        // 3) Константы для страницы
        const float PageMargin = 10f;
        const float A4WidthMm = 297f;
        const float A4HeightMm = 210f;


        static void OnViewModelChanged(BindableObject bindable, object _, object newValue)
        {
            var ctl = (PipeProfileView)bindable;

            //if (newValue is not MainViewModel vm)
            //    return;

            // отписываем старый
            if (ctl._subscribedVm != null)
                ctl._subscribedVm.PropertyChanged -= ctl.OnMainVmPropertyChanged;

            if (newValue is MainViewModel vm)
            {
                ctl._subscribedVm = vm;
                ctl.BindingContext = vm;
                vm.PropertyChanged += ctl.OnMainVmPropertyChanged;
            }
            else
            {
                ctl._subscribedVm = null;
                ctl.BindingContext = null;
                return;
            }

            // убираем старые, если были
            ctl.DetachViewModel();

            ctl.BindingContext = vm;
            ctl.AttachViewModel();

            // защищаемся от того, что _stamp ещё не создан
            if (ctl._stamp != null)
                ctl._stamp.StampCells = vm.StampCells;

            if (ctl._editorManager != null)
                ctl._editorManager.SetViewModel(vm);

            ctl.CanvasView?.InvalidateSurface();
        }

        // 2. Метод-обработчик
        private void OnMainVmPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(MainViewModel.ShowMarkers))
            {
                // инвалидируем холст, чтобы перерисовать без маркеров/с маркерами
                CanvasView.InvalidateSurface();
            }
        }

        private void AttachViewModel()
        {
            // VM обновился: перерисовывать при изменении точек
            ViewModel.GroundVm.GroundPoints.CollectionChanged += OnPointsChanged;
            ViewModel.PipeVm.PipePoints.CollectionChanged += OnPointsChanged;

            // Для каждой точки подписываемся на изменение полей
            foreach (var p in ViewModel.GroundVm.GroundPoints)
                p.PropertyChanged += OnPointPropertyChanged;
            foreach (var p in ViewModel.PipeVm.PipePoints)
                p.PropertyChanged += OnPointPropertyChanged;
        }

        private void DetachViewModel()
        {
            if (ViewModel == null) return;
            ViewModel.GroundVm.GroundPoints.CollectionChanged -= OnPointsChanged;
            ViewModel.PipeVm.PipePoints.CollectionChanged -= OnPointsChanged;

            foreach (var p in ViewModel.GroundVm.GroundPoints)
                p.PropertyChanged -= OnPointPropertyChanged;
            foreach (var p in ViewModel.PipeVm.PipePoints)
                p.PropertyChanged -= OnPointPropertyChanged;
        }

        private void OnPointsChanged(object s, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            // перерисовывать при добавлении/удалении
            CanvasView.InvalidateSurface();

            // подпишем/отпишем новых точек
            if (e.NewItems != null)
                foreach (GroundPoint p in e.NewItems)
                    p.PropertyChanged += OnPointPropertyChanged;
            if (e.OldItems != null)
                foreach (GroundPoint p in e.OldItems)
                    p.PropertyChanged -= OnPointPropertyChanged;
            // аналогично для PipePoints
        }

        private void OnPointPropertyChanged(object s, PropertyChangedEventArgs e)
        {
            // любое изменение Distance или Depth или Elevation
            if (e.PropertyName == nameof(PipePoint.Distance_m)
             || e.PropertyName == nameof(PipePoint.Depth_cm)
             || e.PropertyName == nameof(GroundPoint.Distance_m)
             || e.PropertyName == nameof(GroundPoint.Elevation_cm))
            {
                CanvasView.InvalidateSurface();
            }
        }

        public double CalculateSheetToPipeRatio()
        {
            if (ViewModel.PipeVm.PipePoints == null || ViewModel.PipeVm.PipePoints.Count == 0)
                return 0.0; // Нет точек трубы

            // 1) Длина листа (в мм)
            float sheetWidthMm = PageConfig.A4WidthMm; // 297 мм

            // 2) Получаем первую точку трубы (PipePoint.Distance в метрах или мм)
            float pipeStartDistance = (float)ViewModel.PipeVm.PipePoints[0].Distance_m;

            // 3) Минимальная координата X в мировых координатах (для профиля)
            float minX = ViewModel.GroundVm.GroundPoints.Min(p => (float)p.Distance_m);

            // 4) Масштаб профиля (пиксели на единицу мира)
            float spanX = ViewModel.GroundVm.GroundPoints.Max(p => (float)p.Distance_m) - minX;
            float scaleX = _profileArea.Width / spanX; // Пиксели на единицу мира

            // 5) Переводим расстояние от начала профиля до трубы в пиксели
            float pipeStartPx = (pipeStartDistance - minX) * scaleX;

            // 6) Расстояние от левого края листа до начала профиля (в пикселях)
            float profileOffsetPx = _profileArea.Left - _sheetRect.Left;

            // 7) Полное расстояние от левого края листа до начала трубы (в пикселях)
            float totalDistancePx = profileOffsetPx + pipeStartPx;

            // 8) Переводим расстояние в миллиметры
            float pxPerMm = _sheetRect.Width / PageConfig.A4WidthMm;
            float totalDistanceMm = totalDistancePx / pxPerMm;

            // 9) Вычисляем отношение
            if (totalDistanceMm == 0) return 0.0; // Избегаем деления на ноль
            return Math.Round(sheetWidthMm / totalDistanceMm, 2); // Округляем до 2 знаков
        }


    }
}

Файл: PipeProfileAppMaui\Controls\RibbonView.xaml
<?xml version="1.0" encoding="utf-8" ?>
<ContentView
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:tab="clr-namespace:MPowerKit.TabView;assembly=MPowerKit.TabView"
    xmlns:vm="clr-namespace:PipeProfileAppMaui.ViewModels"
    x:Class="PipeProfileAppMaui.Controls.RibbonView">

    <!-- Переносим ViewModelLocator в Resources, чтобы вызывать команды -->
    <!--<ContentView.Resources>
        <vm:ViewModelLocator x:Key="Locator" />
    </ContentView.Resources>-->

    <tab:TabView
      BackgroundColor="#F5F5F5">

            <!-- Вкладка «Главная» -->
            <tab:TabViewItem Header="Главная">
                <HorizontalStackLayout Spacing="8" Padding="4">
                    <Button
            Text="💾 PDF"
            Command="{Binding Source={StaticResource Locator}, Path=MainViewModel.SavePdfCommand}" />
                    <Button
            Text="📂 Загрузить"
            Command="{Binding Source={StaticResource Locator}, Path=MainViewModel.LoadFromFileCommand}" />
                    <Button
            Text="🔢 Точки"
            Command="{Binding Source={StaticResource Locator}, Path=MainViewModel.ToggleShowPointNumbersCommand}" />
                    <Label Text="{Binding Source={StaticResource Locator}, Path=MainViewModel.ScreenOffsetRatioDisplay}"
            VerticalOptions="Center" />
                    
             <Label Text="X:"
               VerticalTextAlignment="Center"
               FontAttributes="Bold" />

                <Label Text="{Binding Source={StaticResource Locator}, Path=MainViewModel.MouseX, StringFormat='{}{0:F2}'}"
               VerticalTextAlignment="Center" />

            <Label Text="Y:"
               VerticalTextAlignment="Center"
               FontAttributes="Bold" />

                <Label Text="{Binding Source={StaticResource Locator}, Path=MainViewModel.MouseY, StringFormat='{}{0:F2}'}"
               VerticalTextAlignment="Center" />
                <!-- Переключатель показа маркеров -->
                <Switch
              IsToggled="{Binding Source={StaticResource Locator}, Path=MainViewModel.ShowMarkers}"
              VerticalOptions="Center" />

                <Label 
                      Text="Маркеры"
                      VerticalOptions="Center" />
            </HorizontalStackLayout>
        </tab:TabViewItem>

            <!-- Вкладка «Вставка» -->
            <tab:TabViewItem Header="Вставка">
                <HorizontalStackLayout Spacing="8" Padding="4">
                    <Button
            Text="➕ Грунт"
            Command="{Binding Source={StaticResource Locator}, Path=MainViewModel.GroundVm.AddPointCommand}" />
                    <Button
            Text="➕ Трубу"
            Command="{Binding Source={StaticResource Locator}, Path=MainViewModel.PipeVm.AddPipePointCommand}" />
                </HorizontalStackLayout>
            </tab:TabViewItem>
        
    </tab:TabView>
</ContentView>

Файл: PipeProfileAppMaui\Controls\RibbonView.xaml.cs
using Microsoft.Maui.Controls;
using PipeProfileAppMaui.ViewModels;

namespace PipeProfileAppMaui.Controls
{
    public partial class RibbonView : ContentView
    {
        public RibbonView()
        {
            InitializeComponent();
        }

        // ����� � XAML ����� ���� ������ �� ����� StaticResource, � �������� �� VM:
        public static readonly BindableProperty ViewModelProperty =
            BindableProperty.Create(
                nameof(ViewModel),
                typeof(RibbonViewModel),
                typeof(RibbonView),
                propertyChanged: OnVmChanged);

        public RibbonViewModel ViewModel
        {
            get => (RibbonViewModel)GetValue(ViewModelProperty);
            set => SetValue(ViewModelProperty, value);
        }

        static void OnVmChanged(BindableObject bindable, object _, object newValue)
        {
            var ctl = (RibbonView)bindable;
            if (newValue is RibbonViewModel vm)
                ctl.BindingContext = vm;
        }
    }
}

Файл: PipeProfileAppMaui\Controls\SideTabView.xaml
<?xml version="1.0" encoding="utf-8" ?>
<ContentView
  xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:mpk="clr-namespace:MPowerKit.TabView;assembly=MPowerKit.TabView"
  xmlns:controls="clr-namespace:PipeProfileAppMaui.Controls"
  x:Class="PipeProfileAppMaui.Controls.SideTabView">

    <!-- TabView рядом с левым краем -->
    <mpk:TabView
        HeaderBarAlignment="Left"
    BackgroundColor="#F5F5F5"
    HorizontalOptions="Fill"
    VerticalOptions="Fill">

        <mpk:TabViewItem >
            <mpk:TabViewItem.Header>
                <StackLayout Orientation="Horizontal"
                                 Spacing="10">
                    <!--<Label Text="111"/>-->
                    <Image Source="ground.png"
                     HeightRequest="24"
                     WidthRequest="24"
                     />
                </StackLayout>
            </mpk:TabViewItem.Header>
            <controls:GroundPointsControl
        GroundPoints="{Binding GroundVm.GroundPoints}"
        AddPointCommand="{Binding GroundVm.AddPointCommand}"
        RemovePointCommand="{Binding GroundVm.RemovePointCommand}"
        IncreaseDistanceCommand="{Binding GroundVm.IncreaseDistanceCommand}"
        DecreaseDistanceCommand="{Binding GroundVm.DecreaseDistanceCommand}" />
        </mpk:TabViewItem>

        <mpk:TabViewItem>
            <mpk:TabViewItem.Header>
                <StackLayout Orientation="Horizontal"
                                 Spacing="10">
                    <!--<Label Text="222"/>-->
                    <Image Source="pipe.png"
                     HeightRequest="24"
                     WidthRequest="24"
                     />
                </StackLayout>
            </mpk:TabViewItem.Header>

            <controls:PipePointsControl
        PipePoints="{Binding PipeVm.PipePoints}"
        AddPointCommand="{Binding PipeVm.AddPipePointCommand}"
        RemovePointCommand="{Binding PipeVm.RemovePipePointCommand}"
        IncreaseDistanceCommand="{Binding PipeVm.IncreasePipeDistanceCommand}"
        DecreaseDistanceCommand="{Binding PipeVm.DecreasePipeDistanceCommand}" />
        </mpk:TabViewItem>

    </mpk:TabView>
</ContentView>

Файл: PipeProfileAppMaui\Controls\SideTabView.xaml.cs
// SideTabView.xaml.cs
using Microsoft.Maui.Controls;

namespace PipeProfileAppMaui.Controls
{
    public partial class SideTabView : ContentView
    {
        public SideTabView()
        {
            InitializeComponent();
        }

        // Прописываем, чтобы BindingContext наследовался от MainPage
        protected override void OnBindingContextChanged()
        {
            base.OnBindingContextChanged();
            // BindingContext уже MainViewModel → внутри TabView можно сразу обращаться к GroundVm и PipeVm
        }
    }
}

Файл: PipeProfileAppMaui\Controls\Stamp.cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using PipeProfileAppMaui.Models;
using SkiaSharp;

namespace PipeProfileAppMaui.Controls
{
    /// <summary>
    /// ГОСТ-штамп с объединёнными ячейками.
    /// </summary>
    public class Stamp
    {
        /// <summary>Ширины колонок в мм</summary>
        public float[] ColumnWidthsMm { get; }

        /// <summary>Высоты строк в мм</summary>
        public float[] RowHeightsMm { get; }

        /// <summary>Текст в каждой ячейке [row][col]</summary>
        public ObservableCollection<ObservableCollection<StampCell>> StampCells { get; set; }

        /// <summary>Списки объединений ячеек</summary>
        public List<CellSpan> Spans { get; } = new();

        public Stamp()
        {
            var columnWidthsMm = new float[] { 70, 100, 230, 150, 100, 700, 50, 50, 50, 50, 120, 180 };
            var rowHeightsMm = Enumerable.Repeat(5f, 11).ToArray();
            ColumnWidthsMm = columnWidthsMm;
            RowHeightsMm = rowHeightsMm;
            var initialCells = new ObservableCollection<ObservableCollection<StampCell>>();
            StampCells = initialCells
                             ?? throw new ArgumentNullException(nameof(initialCells));
            this.Spans.AddRange(new[]
            {
              new CellSpan(0, 5, 2, 7),  // Код проекта
              new CellSpan(2, 5, 3, 7),  // Наименование проекта
              new CellSpan(5, 0, 1, 2),  // Исп
              new CellSpan(6, 0, 1, 2),  // Пров. 1
              new CellSpan(7, 0, 1, 2),  // Пров. 2
              new CellSpan(8, 0, 1, 2),  // Пров. 3
              new CellSpan(9, 0, 1, 2),  // Пров. 4
              new CellSpan(10, 0, 1, 2),  // Пров. 5
              new CellSpan(5, 5, 3, 1),  // Труба
              new CellSpan(8, 5, 3, 1),  // Нижний левый блок
              new CellSpan(8, 6, 3, 6),  // Нижний правый блок
              new CellSpan(6, 6, 2, 3),  // Наим стадии
              new CellSpan(5, 6, 1, 3),  // Заголовок стадия
              new CellSpan(6, 9, 2, 2),  // Номер листа
              new CellSpan(5, 9, 1, 2),  // Заголовок лист
              new CellSpan(6, 11, 2, 1),  // Кол-во листов
            });
        }

        /// <summary>
        /// Рисует рамки ячеек и текст, учитывая объединения.
        /// </summary>
        public void Draw(SKCanvas canvas, SKRect area)
        {
            // мм→пиксели
            float totalW = ColumnWidthsMm.Sum();
            float totalH = RowHeightsMm.Sum();
            float pxX = area.Width / totalW;
            float pxY = area.Height / totalH;

            using var framePaint = new SKPaint
            {
                Style = SKPaintStyle.Stroke,
                Color = SKColors.Black,
                StrokeWidth = 1,
                IsAntialias = true
            };

            // Шрифт: 4 мм строки
            float fontSize = pxY * 3f;
            using var textPaint = new SKPaint
            {
                Color = SKColors.Black,
                TextSize = fontSize,
                IsAntialias = true
            };
            var fm = textPaint.FontMetrics;
            float lineH = fm.Descent - fm.Ascent;

            // Пробегаем по всем клеткам
            float yAccum = area.Top;
            for (int r = 0; r < RowHeightsMm.Length; r++)
            {
                float rowH = RowHeightsMm[r] * pxY;
                float xAccum = area.Left;

                for (int c = 0; c < ColumnWidthsMm.Length; c++)
                {
                    // Проверяем, начало ли спана или «внутренняя» клетка
                    var cover = Spans.FirstOrDefault(s =>
                        s.Row <= r && r < s.Row + s.RowSpan &&
                        s.Col <= c && c < s.Col + s.ColSpan);

                    // если interior—пропустить
                    if (cover != null && (cover.Row != r || cover.Col != c))
                    {
                        xAccum += ColumnWidthsMm[c] * pxX;
                        continue;
                    }

                    // Размер спана
                    int row0 = cover?.Row ?? r;
                    int col0 = cover?.Col ?? c;
                    int rs = cover?.RowSpan ?? 1;
                    int cs = cover?.ColSpan ?? 1;

                    // Расчёт rect спана
                    float x0 = area.Left + ColumnWidthsMm.Take(col0).Sum() * pxX;
                    float y0 = area.Top + RowHeightsMm.Take(row0).Sum() * pxY;
                    float w = ColumnWidthsMm.Skip(col0).Take(cs).Sum() * pxX;
                    float h = RowHeightsMm.Skip(row0).Take(rs).Sum() * pxY;
                    var rect = new SKRect(x0, y0, x0 + w, y0 + h);

                    // 1) Рисуем рамку объединённой клетки
                    canvas.DrawRect(rect, framePaint);

                    // 2) Клиппинг → текст вписывается внутрь
                    canvas.Save();
                    canvas.ClipRect(rect);

                    string txt = StampCells[row0][col0].Text ?? "";
                    var lines = txt.Split(new[] { "\r\n", "\n", "\r" }, StringSplitOptions.None);
                    float totalTextH = lines.Length * lineH;
                    float yText = rect.Top + (rect.Height - totalTextH) / 2 - fm.Ascent;

                    foreach (var line in lines)
                    {
                        float tw = textPaint.MeasureText(line);
                        float xText = rect.Left + (rect.Width - tw) / 2;
                        canvas.DrawText(line, xText, yText, textPaint);
                        yText += lineH;
                    }

                    canvas.Restore();

                    xAccum += ColumnWidthsMm[c] * pxX;
                }

                yAccum += rowH;
            }
        }        /// <summary>
                 /// Возвращает (row,col) ячейки по точке в «мировых» пикселях.
                 /// </summary>
        public (int row, int col)? HitTest(SKPoint worldPoint, SKRect area)
        {
            float totalW = ColumnWidthsMm.Sum();
            float totalH = RowHeightsMm.Sum();
            float pxX = area.Width / totalW;
            float pxY = area.Height / totalH;

            float dx = (worldPoint.X - area.Left) / pxX;
            float dy = (worldPoint.Y - area.Top) / pxY;

            float accY = 0;
            for (int r = 0; r < RowHeightsMm.Length; r++)
            {
                float rowH = RowHeightsMm[r];
                float accX = 0;
                for (int c = 0; c < ColumnWidthsMm.Length; c++)
                {
                    var span = Spans
                        .FirstOrDefault(s => s.Row == r && s.Col == c);
                    int rs = span?.RowSpan ?? 1;
                    int cs = span?.ColSpan ?? 1;
                    float cellW = ColumnWidthsMm.Skip(c).Take(cs).Sum();
                    float cellH = RowHeightsMm.Skip(r).Take(rs).Sum();

                    if (dx >= accX && dx < accX + cellW &&
                        dy >= accY && dy < accY + cellH)
                    {
                        return (r, c);
                    }

                    accX += ColumnWidthsMm[c];
                }
                accY += rowH;
            }
            return null;
        }

        /// <summary>
        /// Задаёт «мировую» область одной ячейки (с учётом span).
        /// </summary>
        public SKRect GetCellRect(int row, int col, SKRect area)
        {
            float totalW = ColumnWidthsMm.Sum();
            float totalH = RowHeightsMm.Sum();
            float pxX = area.Width / totalW;
            float pxY = area.Height / totalH;

            var span = Spans
                .FirstOrDefault(s =>
                    s.Row <= row && row < s.Row + s.RowSpan &&
                    s.Col <= col && col < s.Col + s.ColSpan);

            int row0 = span?.Row ?? row;
            int col0 = span?.Col ?? col;
            int rs = span?.RowSpan ?? 1;
            int cs = span?.ColSpan ?? 1;

            float x = area.Left + ColumnWidthsMm.Take(col0).Sum() * pxX;
            float y = area.Top + RowHeightsMm.Take(row0).Sum() * pxY;
            float w = ColumnWidthsMm.Skip(col0).Take(cs).Sum() * pxX;
            float h = RowHeightsMm.Skip(row0).Take(rs).Sum() * pxY;

            return new SKRect(x, y, x + w, y + h);
        }
    }

    /// <summary>Описывает объединённую область ячеек.</summary>
    public record CellSpan(int Row, int Col, int RowSpan, int ColSpan);
}

Файл: PipeProfileAppMaui\Converters\BoolToStateConverter.cs
// File: Converters/BoolToStateConverter.cs
using System;
using System.Globalization;
using Microsoft.Maui.Controls;

namespace PipeProfileAppMaui.Converters
{
    public class BoolToStateConverter : IValueConverter
    {
        // возвращает имя визуального состояния: "Selected" или "Normal"
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool b && b)
                return "Selected";
            return "Normal";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
          => throw new NotImplementedException();
    }
}

Файл: PipeProfileAppMaui\Converters\HeaderEqualsConverter.cs
using System;
using System.Globalization;
using Microsoft.Maui.Controls;

namespace PipeProfileAppMaui.Converters
{
    public class HeaderEqualsConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return value?.ToString() == (string)parameter;
        }

        //public object ConvertBack(...) => throw new NotImplementedException();

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


Файл: PipeProfileAppMaui\Converters\SelectedTabBackgroundConverter.cs
using System;
using System.Globalization;
using Microsoft.Maui;
using Microsoft.Maui.Controls;
using PipeProfileAppMaui.ViewModels;

namespace PipeProfileAppMaui.Converters
{
    public class SelectedTabBackgroundConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // value — текущий RibbonTab
            // parameter — SelectedRibbonTab из VM
            if (parameter is RibbonTab selected
                && value is RibbonTab current
                && ReferenceEquals(selected, current))
            {
                return Colors.LightGray; // цвет подсветки
            }
            return Colors.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
          => throw new NotImplementedException();
    }
}

Файл: PipeProfileAppMaui\Helpers\DrawingHelpers.cs
using SkiaSharp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PipeProfileAppMaui.Helpers
{
    public static class DrawingHelpers
    {
        // 1) Рассчитать letterbox-область нужного отношения
        public static SKRect CalculateLetterbox(
            SKSize canvasSize, float margin, float targetRatio)
        {
            float maxW = canvasSize.Width - 2 * margin;
            float maxH = canvasSize.Height - 2 * margin;
            float canvasRatio = maxW / maxH;
            float w = canvasRatio > targetRatio
                      ? maxH * targetRatio
                      : maxW;
            float h = w / targetRatio;
            float x = margin + (maxW - w) / 2;
            float y = margin + (maxH - h) / 2;
            return new SKRect(x, y, x + w, y + h);
        }

        // 2) Отрисовать фон + рамки листа
        public static void DrawPageFrame(
            this SKCanvas canvas, SKImageInfo info, SKRect sheetRect)
        {
            // градиент
            using var bg = new SKPaint
            {
                IsAntialias = true,
                Shader = SKShader.CreateLinearGradient(
                    new SKPoint(0, 0),
                    new SKPoint(info.Width * 0.2f, info.Height * 0.2f),
                    new[] { SKColors.LightSkyBlue, SKColors.White },
                    null,
                    SKShaderTileMode.Clamp)
            };
            canvas.Save();
            canvas.ClipRect(sheetRect, SKClipOperation.Difference);
            canvas.DrawRect(-info.Width, -info.Height, info.Width * 2, info.Height * 2, bg);
            canvas.Restore();

            // рамка ГОСТ
            using var frame = new SKPaint
            {
                Style = SKPaintStyle.Stroke,
                Color = SKColors.Black,
                StrokeWidth = 1,
                IsAntialias = true
            };
            canvas.DrawRect(sheetRect, frame);
        }

        // 3) Собрать матрицу вписывания «мир→прямоугольник»
        public static SKMatrix ComposeWorldToArea(
            SKRect area,
            double minX, double maxX,
            double minY, double maxY)
        {
            float spanX = (float)(maxX - minX);
            float spanY = (float)(maxY - minY);

            var scale = SKMatrix.CreateScale(area.Width / spanX, -area.Height / spanY);
            var shiftWorld = SKMatrix.CreateTranslation((float)-minX, (float)-minY);
            var shiftArea = SKMatrix.CreateTranslation(area.Left, area.Bottom);

            return SKMatrix.Concat(shiftArea,
                   SKMatrix.Concat(scale, shiftWorld));
        }
    }
}


Файл: PipeProfileAppMaui\Helpers\PageConfig.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PipeProfileAppMaui.Helpers
{
    public static class PageConfig
    {
        public const float A4WidthMm = 297f;
        public const float A4HeightMm = 210f;
        public const float PageMargin = 10f;

        public const float ProfileInsetTop = 20f;
        public const float ProfileInsetLeft = 30f;
        public const float ProfileInsetRight = 30f;
        public const float ProfileInsetBottom = 140f;

        public const float StampHeightMm = 55f;
        public const float StampWidthMm = 180f;
    }
}


Файл: PipeProfileAppMaui\Helpers\TextDrawingHelper.cs
// File: Helpers/TextDrawingHelper.cs
using SkiaSharp;

namespace PipeProfileAppMaui.Helpers
{
    /// <summary>
    /// Вспомогательные методы для рисования текста GOST_Type_AU
    /// центрированного над и под заданной точкой.
    /// </summary>
    public static class TextDrawingHelper
    {
        // Typeface один раз, на всё приложение
        private static readonly SKTypeface GostTypeface =
            SKTypeface.FromFamilyName("GOST_Type_AU", 
                                        SKFontStyleWeight.Normal,
                                        SKFontStyleWidth.Normal,
                                        SKFontStyleSlant.Italic);
        public const float defFontHeight = 14, textSpace = 0;

        /// <summary>
        /// Создаёт SKPaint с нужным размером и цветом.
        /// </summary>
        private static SKPaint CreatePaint(float textSize, SKColor color) =>
            new SKPaint
            {
                Typeface = GostTypeface,
                TextSize = textSize,
                Color = color,
                IsAntialias = true
                
            };

        /// <summary>
        /// Измеряет ширину текста в пикселях.
        /// </summary>
        public static float MeasureTextWidth(string text, SKPaint? paint = null)
        {
            var p = paint ?? CreatePaint(14f, SKColors.Black);
            return p.MeasureText(text);
        }

        /// <summary>
        /// Измеряет высоту текста в пикселях (descent − ascent).
        /// </summary>
        public static float MeasureTextHeight(string text, SKPaint? paint = null)
        {
            var p = paint ?? CreatePaint(14f, SKColors.Black);
            var fm = p.FontMetrics;
            return fm.Descent - fm.Ascent;
        }

        /// <summary>
        /// Рисует text над точкой point, центрируя по X.
        /// </summary>
        /// <param name="canvas">SKCanvas для рисования.</param>
        /// <param name="point">Точка-ориентир.</param>
        /// <param name="text">Текст для рисования.</param>
        /// <param name="textSize">Размер текста в пикселях.</param>
        /// <param name="offset">Отступ от точки по Y (px).</param>
        /// <param name="color">Цвет текста.</param>
        public static void DrawTextAbovePoint(
            this SKCanvas canvas,
            SKPoint point,
            string text,
            float textSize = defFontHeight,
            float offset = textSpace,
            SKColor? color = null)
        {
            using var paint = CreatePaint(textSize, color ?? SKColors.Black);
            var fm = paint.FontMetrics;
            var w = paint.MeasureText(text);
            // X так, чтобы текст был по центру
            var x = point.X - w / 2f;
            // baselineY: point.Y minus offset и minus descent,
            // чтобы низ текста был ровно offset выше точки
            var y = point.Y - offset - fm.Descent;

            canvas.DrawText(text, x, y, paint);
        }

        /// <summary>
        /// Рисует text под точкой point, центрируя по X.
        /// </summary>
        /// <param name="canvas">SKCanvas для рисования.</param>
        /// <param name="point">Точка-ориентир.</param>
        /// <param name="text">Текст для рисования.</param>
        /// <param name="textSize">Размер текста в пикселях.</param>
        /// <param name="offset">Отступ от точки по Y (px).</param>
        /// <param name="color">Цвет текста.</param>
        public static void DrawTextBelowPoint(
            this SKCanvas canvas,
            SKPoint point,
            string text,
            float textSize = defFontHeight,
            float offset = textSpace,
            SKColor? color = null)
        {
            using var paint = CreatePaint(textSize, color ?? SKColors.Black);
            var fm = paint.FontMetrics;
            var w = paint.MeasureText(text);
            // X так, чтобы текст был по центру
            var x = point.X - w / 2f;
            // baselineY: point.Y plus offset и minus ascent,
            // чтобы верх текста был ровно offset ниже точки
            var y = point.Y + offset - fm.Ascent;

            canvas.DrawText(text, x, y, paint);
        }
    }
}

Файл: PipeProfileAppMaui\Models\GroundPoint.cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace PipeProfileAppMaui.Models
{
    public class GroundPoint : INotifyPropertyChanged, IDataErrorInfo
    {
        // Дистанция в метрах
        private double _distance_m;
        // Возвышение в сантиметрах
        private double _elevation_cm;
        private bool _isHighlighted;
        private int _index;
        public int Index
        {
            get => _index;
            set
            {
                if (_index != value)
                {
                    _index = value;
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Index)));
                }
            }
        }

        public double Distance_m
        {
            get => _distance_m;
            set { if (_distance_m != value) { _distance_m = value; OnPropertyChanged(); } }
        }

        public double Elevation_cm
        {
            get => _elevation_cm;
            set { if (_elevation_cm != value) { _elevation_cm = value; OnPropertyChanged(); } }
        }

        public bool IsHighlighted
        {
            get => _isHighlighted;
            set { if (_isHighlighted != value) { _isHighlighted = value; OnPropertyChanged(); } }
        }

        public string Error => null;

        public string this[string columnName]
        {
            get
            {
                switch (columnName)
                {
                    case nameof(Distance_m):
                        if (Distance_m < 0) return "Distance must be non-negative.";
                        break;
                    case nameof(Elevation_cm):
                        if (Elevation_cm < -1000 || Elevation_cm > 10000) return "Elevation must be between -1000 and 10000.";
                        break;
                }
                return null;
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

Файл: PipeProfileAppMaui\Models\PipePoint.cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace PipeProfileAppMaui.Models
{
    public class PipePoint : INotifyPropertyChanged, IDataErrorInfo
    {
        // Дистанция в метрах
        private double _distance_m;
        // Глубина в сантиметрах
        private double _depth_cm;
        private bool _isHighlighted;

        private int _index;
        public int Index
        {
            get => _index;
            set
            {
                if (_index != value)
                {
                    _index = value;
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Index)));
                }
            }
        }
        public double Distance_m
        {
            get => _distance_m;
            set { if (_distance_m != value) { _distance_m = value; OnPropertyChanged(); } }
        }

        public double Depth_cm
        {
            get => _depth_cm;
            set { if (_depth_cm != value) { _depth_cm = value; OnPropertyChanged(); } }
        }

        public bool IsHighlighted
        {
            get => _isHighlighted;
            set { if (_isHighlighted != value) { _isHighlighted = value; OnPropertyChanged(); } }
        }

        public string Error => null;

        public string this[string columnName]
        {
            get
            {
                switch (columnName)
                {
                    case nameof(Distance_m):
                        if (Distance_m < 0) return "Distance must be non-negative.";
                        break;
                    case nameof(Depth_cm):
                        if (Depth_cm < 0 || Depth_cm > 100) return "Depth must be between 0 and 100.";
                        break;
                }
                return null;
            }
        }



        public event PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

Файл: PipeProfileAppMaui\Models\StampCell.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PipeProfileAppMaui.Models
{
    public class StampCell : INotifyPropertyChanged
    {
        private string _text;
        public string Text
        {
            get => _text;
            set
            {
                if (_text != value)
                {
                    _text = value;
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Text)));
                }
            }
        }
        public event PropertyChangedEventHandler PropertyChanged;
    }
}


Файл: PipeProfileAppMaui\MPowerKit.TabView\Alignment.cs
namespace MPowerKit.TabView;

public enum Alignment
{
    Top,
    Bottom,
    Left,
    Right
}

Файл: PipeProfileAppMaui\MPowerKit.TabView\InverseBooleanConverter.cs
using System.Globalization;

namespace MPowerKit.TabView;

public class InverseBooleanConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is bool boolean)
        {
            return !boolean;
        }

        return value;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}

Файл: PipeProfileAppMaui\MPowerKit.TabView\ItemsPresenter.cs
namespace MPowerKit.TabView;

public class ItemsPresenter : ContentView
{
}

Файл: PipeProfileAppMaui\MPowerKit.TabView\MPowerKit.TabView.csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFrameworks>net8.0;net9.0</TargetFrameworks>
		<UseMaui>true</UseMaui>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>

		<GeneratePackageOnBuild>True</GeneratePackageOnBuild>
		<Title>MPowerKit.TabView</Title>
		<Version>1.3.0</Version>
		<Authors>MPowerKit,Alex Dobrynin</Authors>
		<Description>Fully customizable .NET MAUI TabView</Description>
		<Copyright>MPowerKit</Copyright>
		<PackageProjectUrl>https://github.com/MPowerKit/TabView</PackageProjectUrl>
		<RepositoryUrl>https://github.com/MPowerKit/TabView</RepositoryUrl>
		<PackageTags>tab view;tabview;maui;tabbedview;tab;tabbed;tabs</PackageTags>
		<PackageLicenseFile>LICENSE</PackageLicenseFile>
		<PackageReadmeFile>readme.md</PackageReadmeFile>
		<PackageIcon>icon.png</PackageIcon>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.Maui.Controls" Version="$(MauiVersion)" />
	</ItemGroup>

	<ItemGroup>
		<None Include="..\LICENSE">
			<Pack>True</Pack>
			<PackagePath>\</PackagePath>
		</None>
		<None Include="..\readme.md">
			<Pack>True</Pack>
			<PackagePath>\</PackagePath>
		</None>
		<None Include="..\icon.png">
			<Pack>True</Pack>
			<PackagePath>\</PackagePath>
		</None>
	</ItemGroup>

</Project>


Файл: PipeProfileAppMaui\MPowerKit.TabView\ScrollOrientationToStackOrientationConverter.cs
using System.Globalization;

namespace MPowerKit.TabView;

public class ScrollOrientationToStackOrientationConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is ScrollOrientation scrollOrientation)
        {
            return scrollOrientation switch
            {
                ScrollOrientation.Horizontal => StackOrientation.Horizontal,
                ScrollOrientation.Vertical => StackOrientation.Vertical,
                _ => throw new ArgumentOutOfRangeException(nameof(scrollOrientation), scrollOrientation, null)
            };
        }

        return StackOrientation.Horizontal;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}

Файл: PipeProfileAppMaui\MPowerKit.TabView\TabVIew.cs
using System.Collections;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Input;

namespace MPowerKit.TabView;

[ContentProperty("Tabs")]
public class TabView : ContentView
{
    protected Grid? ContentContainer;
    protected ScrollView? HeadersScroll;
    protected TabViewItem? PrevSelectedTabItem;
    protected Layout HeadersContainer;

    protected bool UseItemsSource => ItemsSource is not null;

    public ObservableCollection<TabViewItem> Tabs { get; } = [];

    protected Layout StackItemsLayout
    {
        get
        {
            var stack = new StackLayout()
            {
                VerticalOptions = LayoutOptions.Fill,
                HorizontalOptions = LayoutOptions.Fill,
                Spacing = 0,
                Orientation = StackOrientation.Horizontal
            };

            stack.SetBinding(StackLayout.OrientationProperty, new Binding(ScrollView.OrientationProperty.PropertyName,
                source: new RelativeBindingSource(RelativeBindingSourceMode.FindAncestor, typeof(ScrollView)),
                converter: new ScrollOrientationToStackOrientationConverter()));

            return stack;
        }
    }

    public TabView()
    {
        Tabs.CollectionChanged += Tabs_CollectionChanged;
    }

    protected override void OnApplyTemplate()
    {
        base.OnApplyTemplate();

        ContentContainer = GetTemplateChild("PART_ContentContainer") as Grid;
        HeadersScroll = GetTemplateChild("PART_HeadersScrollView") as ScrollView;

        InitHeaderBarLayout();
    }

    protected virtual void InitHeaderBarLayout()
    {
        if (HeadersScroll == null || HeadersScroll.Content is not ItemsPresenter presenter) return;

        var newLayout = HeaderItemsLayout ?? StackItemsLayout;

        if (HeadersContainer != null)
        {
            foreach (var item in HeadersContainer.Children)
            {
                newLayout.Children.Add(item);
            }

            HeadersContainer.Children.Clear();
        }

        HeadersContainer = newLayout;

        presenter.Content = HeadersContainer;
    }

    protected override void OnBindingContextChanged()
    {
        base.OnBindingContextChanged();

        if (BindingContext is not null && !UseItemsSource)
        {
            foreach (var tab in Tabs)
            {
                if (tab.BindingContext != BindingContext)
                    tab.BindingContext = BindingContext;
            }
        }
    }

    protected override void OnPropertyChanging([CallerMemberName] string? propertyName = null)
    {
        base.OnPropertyChanging(propertyName);

        if (propertyName == ItemsSourceProperty.PropertyName && ItemsSource is not null)
        {
            if (ItemsSource is INotifyCollectionChanged itemsSource)
                itemsSource.CollectionChanged -= ItemsSource_CollectionChanged;

            Tabs.Clear();
        }
        else if (propertyName == SelectedTabIndexProperty.PropertyName)
        {
            PrevSelectedTabItem = Tabs.ElementAtOrDefault(SelectedTabIndex);
        }
    }

    protected override void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        base.OnPropertyChanged(propertyName);

        if (propertyName == ItemsSourceProperty.PropertyName && ItemsSource is not null)
        {
            if (ItemsSource is INotifyCollectionChanged itemsSource)
                itemsSource.CollectionChanged += ItemsSource_CollectionChanged;

            InitItems(ItemsSource);
        }
        else if (propertyName == SelectedTabIndexProperty.PropertyName)
        {
            if (PrevSelectedTabItem is not null) PrevSelectedTabItem.IsSelected = false;

            var newTab = Tabs.ElementAtOrDefault(SelectedTabIndex);
            if (newTab is not null)
            {
                if (newTab.IsEnabled)
                {
                    newTab.IsSelected = true;
                }
                else
                {
                    SelectClosestEnabledTab(newTab);
                    return;
                }
            }

            if (SelectedTabChangedCommand?.CanExecute(SelectedTabChangedCommandParameter) is true)
                SelectedTabChangedCommand.Execute(SelectedTabChangedCommandParameter);
        }
        else if (propertyName == ContentTemplateProperty.PropertyName && UseItemsSource)
        {
            foreach (var tab in Tabs)
            {
                var index = Tabs.IndexOf(tab);
                InitTabContentTemplate(tab.BindingContext, tab);
            }
        }
        else if (propertyName == HeaderItemsLayoutProperty.PropertyName)
        {
            InitHeaderBarLayout();
        }
    }

    protected virtual void InitItems(IEnumerable source, int index = 0, bool useIndex = false)
    {
        if (source is null) return;

        foreach (var item in source)
        {
            var tabItem = new TabViewItem();
            InitTabContentTemplate(item, tabItem);

            tabItem.BindingContext = item;
            tabItem.Header = item;

            if (useIndex) Tabs.Insert(index, tabItem);
            else Tabs.Add(tabItem);
        }
    }

    protected virtual void InitTabContentTemplate(object item, TabViewItem tabItem)
    {
        if (ContentTemplate is not null)
        {
            var template = ContentTemplate;
            if (ContentTemplate is DataTemplateSelector selector) template = selector.SelectTemplate(item, this);

            var tabContent = template.CreateContent() as View;
            tabContent!.BindingContext ??= item;

            tabItem.Content = tabContent;
            return;
        }

        tabItem.Content = new Label
        {
            Text = item.ToString()
        };
    }

    protected virtual void ItemsSource_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        switch (e.Action)
        {
            case NotifyCollectionChangedAction.Add:
                ItemsAdd(e);
                break;
            case NotifyCollectionChangedAction.Move:
                ItemsMove(e);
                break;
            case NotifyCollectionChangedAction.Remove:
                ItemsRemove(e);
                break;
            case NotifyCollectionChangedAction.Replace:
                ItemsReplace(e);
                break;
            case NotifyCollectionChangedAction.Reset:
                ItemsReset(e);
                break;
        }
    }

    protected virtual void ItemsAdd(NotifyCollectionChangedEventArgs e)
    {
        InitItems(e.NewItems!, e.NewStartingIndex, true);
    }

    protected virtual void ItemsMove(NotifyCollectionChangedEventArgs e)
    {
        Tabs.Move(e.OldStartingIndex, e.NewStartingIndex);
    }

    protected virtual void ItemsRemove(NotifyCollectionChangedEventArgs e)
    {
        if (e.OldItems is null) return;

        if (e.OldStartingIndex + e.OldItems.Count < SelectedTabIndex)
        {
            SelectedTabIndex -= e.OldItems.Count;
        }
        else if (SelectedTabIndex >= e.OldStartingIndex
            && SelectedTabIndex <= e.OldStartingIndex + e.OldItems.Count)
        {
            var newIndex = e.OldStartingIndex + e.OldItems.Count + 1;
            if (newIndex > Tabs.Count) newIndex = -1;
            SelectedTabIndex = newIndex;
        }

        foreach (var item in e.OldItems)
        {
            Tabs.RemoveAt(e.OldStartingIndex);
        }
    }

    protected virtual void ItemsReplace(NotifyCollectionChangedEventArgs e)
    {
        ItemsRemove(e);
        ItemsAdd(e);
    }

    protected virtual void ItemsReset(NotifyCollectionChangedEventArgs e)
    {
        foreach (var item in Tabs)
        {
            item.PropertyChanged -= TabItem_PropertyChanged;
        }

        Tabs.Clear();

        InitItems(ItemsSource);
    }

    protected virtual void Tabs_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        switch (e.Action)
        {
            case NotifyCollectionChangedAction.Add:
                {
                    foreach (TabViewItem item in e.NewItems!)
                    {
                        item!.PropertyChanged += TabItem_PropertyChanged;

                        HeadersContainer?.Children.Insert(e.NewStartingIndex, item.TabViewHeaderItem);
                        ContentContainer?.Children.Insert(e.NewStartingIndex, item);
                    }

                    TabsInitialSelection(e);
                }
                break;
            case NotifyCollectionChangedAction.Move:
                {
                    if (HeadersContainer is not null)
                    {
                        var header = HeadersContainer.Children.ElementAt(e.OldStartingIndex);
                        HeadersContainer.Children.Remove(header);
                        HeadersContainer.Children.Insert(e.NewStartingIndex, header);
                    }

                    if (ContentContainer is not null)
                    {
                        var content = ContentContainer.Children.ElementAt(e.OldStartingIndex);
                        ContentContainer.Children.Remove(content);
                        ContentContainer.Children.Insert(e.NewStartingIndex, content);
                    }
                }
                break;
            case NotifyCollectionChangedAction.Remove:
                {
                    foreach (TabViewItem item in e.OldItems!)
                    {
                        item!.PropertyChanged -= TabItem_PropertyChanged;

                        HeadersContainer?.Children.RemoveAt(e.OldStartingIndex);
                        ContentContainer?.Children.RemoveAt(e.OldStartingIndex);
                    }
                }
                break;
            case NotifyCollectionChangedAction.Replace:
                break;
            case NotifyCollectionChangedAction.Reset:
                {
                    HeadersContainer?.Children.Clear();
                    ContentContainer?.Children.Clear();
                    SelectedTabIndex = -1;
                }
                break;
        }
    }

    protected virtual void TabsInitialSelection(NotifyCollectionChangedEventArgs e)
    {
        if (SelectedTabIndex == -1)
        {
            if (Tabs.Any(t => t.IsSelected))
            {
                SelectedTabIndex = Tabs.IndexOf(Tabs.First(t => t.IsSelected));
            }
            else
            {
                var tab = Tabs.First();
                if (!tab.IsEnabled) SelectClosestEnabledTab(tab);
                else SelectedTabIndex = 0;
            }
        }
        else
        {
            if (!Tabs.Any(t => t.IsSelected))
            {
                var tab = Tabs.ElementAtOrDefault(SelectedTabIndex);
                if (tab is null)
                {
                    if (Tabs.Count == 0) SelectedTabIndex = -1;
                    else SelectedTabIndex = 0;
                    return;
                }
                if (!tab.IsEnabled) SelectClosestEnabledTab(tab);
                else tab.IsSelected = true;
            }
            else if (e.NewStartingIndex <= SelectedTabIndex)
                SelectedTabIndex += (e.NewItems?.Count ?? 0) - (e.OldItems?.Count ?? 0);
        }
    }

    protected virtual void TabItem_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        var tab = (sender as TabViewItem)!;

        if (e.PropertyName == TabViewItem.IsSelectedProperty.PropertyName && tab.IsSelected)
        {
            if (!tab.IsEnabled)
            {
                SelectClosestEnabledTab(tab);
                return;
            }

            SelectedTabIndex = Tabs.IndexOf(tab);

            if (HeadersScroll is null || !ScrollToSelectedTab) return;

            if (HeaderBarAlignment is Alignment.Top or Alignment.Bottom
                && HeadersContainer.Width > HeadersScroll.Width)
            {
                var max = HeadersContainer.Width - HeadersScroll.Width;
                var scrollTo = tab.TabViewHeaderItem.X - (HeadersScroll.Width - tab.TabViewHeaderItem.Width) / 2.0;
                scrollTo = Math.Max(0d, Math.Min(max, scrollTo));

                HeadersScroll.ScrollToAsync(scrollTo, 0d, true);
            }
            else if (HeaderBarAlignment is Alignment.Left or Alignment.Right
                && HeadersContainer.Height > HeadersScroll.Height)
            {
                var max = HeadersContainer.Height - HeadersScroll.Height;
                var scrollTo = tab.TabViewHeaderItem.Y - (HeadersScroll.Height - tab.TabViewHeaderItem.Height) / 2.0;
                scrollTo = Math.Max(0d, Math.Min(max, scrollTo));

                HeadersScroll.ScrollToAsync(0d, scrollTo, true);
            }
        }
        else if (e.PropertyName == TabViewItem.IsEnabledProperty.PropertyName)
        {
            if (!tab.IsEnabled && tab.IsSelected) SelectClosestEnabledTab(tab);
            else if (tab.IsEnabled && !Tabs.Any(t => t.IsSelected))
            {
                var index = Tabs.IndexOf(tab);
                SelectedTabIndex = index;
            }
        }
    }

    protected virtual void SelectClosestEnabledTab(TabViewItem tab)
    {
        var tabs = Tabs.Where(t => t.IsEnabled || t == tab).ToList();

        if (tabs.Count == 1)
        {
            SelectedTabIndex = -1;
            return;
        }

        var index = tabs.IndexOf(tab);

        tabs[index + (index == tabs.Count - 1 ? -1 : 1)].IsSelected = true;
    }

    #region HideTabsWhenDisabled
    public bool HideTabsWhenDisabled
    {
        get { return (bool)GetValue(HideTabsWhenDisabledProperty); }
        set { SetValue(HideTabsWhenDisabledProperty, value); }
    }

    public static readonly BindableProperty HideTabsWhenDisabledProperty =
        BindableProperty.Create(
            nameof(HideTabsWhenDisabled),
            typeof(bool),
            typeof(TabView),
            true
            );
    #endregion

    #region HeaderItemsLayout
    public Layout HeaderItemsLayout
    {
        get { return (Layout)GetValue(HeaderItemsLayoutProperty); }
        set { SetValue(HeaderItemsLayoutProperty, value); }
    }

    public static readonly BindableProperty HeaderItemsLayoutProperty =
        BindableProperty.Create(
            nameof(HeaderItemsLayout),
            typeof(Layout),
            typeof(TabView)
            );
    #endregion

    #region ScrollToSelectedTab
    public bool ScrollToSelectedTab
    {
        get { return (bool)GetValue(ScrollToSelectedTabProperty); }
        set { SetValue(ScrollToSelectedTabProperty, value); }
    }

    public static readonly BindableProperty ScrollToSelectedTabProperty =
        BindableProperty.Create(
            nameof(ScrollToSelectedTab),
            typeof(bool),
            typeof(TabView),
            true
            );
    #endregion

    #region ContentBackgroundColor
    public Color ContentBackgroundColor
    {
        get { return (Color)GetValue(ContentBackgroundColorProperty); }
        set { SetValue(ContentBackgroundColorProperty, value); }
    }

    public static readonly BindableProperty ContentBackgroundColorProperty =
        BindableProperty.Create(
            nameof(ContentBackgroundColor),
            typeof(Color),
            typeof(TabView),
            Colors.Transparent
            );
    #endregion

    #region HeaderBarBackgroundColor
    public Color HeaderBarBackgroundColor
    {
        get { return (Color)GetValue(HeaderBarBackgroundColorProperty); }
        set { SetValue(HeaderBarBackgroundColorProperty, value); }
    }

    public static readonly BindableProperty HeaderBarBackgroundColorProperty =
        BindableProperty.Create(
            nameof(HeaderBarBackgroundColor),
            typeof(Color),
            typeof(TabView),
            Colors.Transparent
            );
    #endregion

    #region SelectedHeaderBackgroundColor
    public Color SelectedHeaderBackgroundColor
    {
        get { return (Color)GetValue(SelectedHeaderBackgroundColorProperty); }
        set { SetValue(SelectedHeaderBackgroundColorProperty, value); }
    }

    public static readonly BindableProperty SelectedHeaderBackgroundColorProperty =
        BindableProperty.Create(
            nameof(SelectedHeaderBackgroundColor),
            typeof(Color),
            typeof(TabView),
            Colors.Blue
            );
    #endregion

    #region HeaderBackgroundColor
    public Color HeaderBackgroundColor
    {
        get { return (Color)GetValue(HeaderBackgroundColorProperty); }
        set { SetValue(HeaderBackgroundColorProperty, value); }
    }

    public static readonly BindableProperty HeaderBackgroundColorProperty =
        BindableProperty.Create(
            nameof(HeaderBackgroundColor),
            typeof(Color),
            typeof(TabView),
            Colors.Transparent
            );
    #endregion

    #region HeaderHeightRequest
    public double HeaderHeightRequest
    {
        get { return (double)GetValue(HeaderHeightRequestProperty); }
        set { SetValue(HeaderHeightRequestProperty, value); }
    }

    public static readonly BindableProperty HeaderHeightRequestProperty =
        BindableProperty.Create(
            nameof(HeaderHeightRequest),
            typeof(double),
            typeof(TabView),
            50.0
            );
    #endregion

    #region HeaderFontFamily
    public string HeaderFontFamily
    {
        get { return (string)GetValue(HeaderFontFamilyProperty); }
        set { SetValue(HeaderFontFamilyProperty, value); }
    }

    public static readonly BindableProperty HeaderFontFamilyProperty =
        BindableProperty.Create(
            nameof(HeaderFontFamily),
            typeof(string),
            typeof(TabView)
            );
    #endregion

    #region HeaderFontSize
    public double HeaderFontSize
    {
        get { return (double)GetValue(HeaderFontSizeProperty); }
        set { SetValue(HeaderFontSizeProperty, value); }
    }

    public static readonly BindableProperty HeaderFontSizeProperty =
        BindableProperty.Create(
            nameof(HeaderFontSize),
            typeof(double),
            typeof(TabView),
            14.0
            );
    #endregion

    #region HeaderFontAttributes
    public FontAttributes HeaderFontAttributes
    {
        get { return (FontAttributes)GetValue(HeaderFontAttributesProperty); }
        set { SetValue(HeaderFontAttributesProperty, value); }
    }

    public static readonly BindableProperty HeaderFontAttributesProperty =
        BindableProperty.Create(
            nameof(HeaderFontAttributes),
            typeof(FontAttributes),
            typeof(TabView),
            FontAttributes.None
            );
    #endregion

    #region HeaderTextColor
    public Color HeaderTextColor
    {
        get { return (Color)GetValue(HeaderTextColorProperty); }
        set { SetValue(HeaderTextColorProperty, value); }
    }

    public static readonly BindableProperty HeaderTextColorProperty =
        BindableProperty.Create(
            nameof(HeaderTextColor),
            typeof(Color),
            typeof(TabView),
            Colors.Black
            );
    #endregion

    #region SelectedTabIndex
    public int SelectedTabIndex
    {
        get { return (int)GetValue(SelectedTabIndexProperty); }
        set { SetValue(SelectedTabIndexProperty, value); }
    }

    public static readonly BindableProperty SelectedTabIndexProperty =
        BindableProperty.Create(
            nameof(SelectedTabIndex),
            typeof(int),
            typeof(TabView),
            -1
            );
    #endregion

    #region SelectedHeaderTemplate
    public DataTemplate SelectedHeaderTemplate
    {
        get { return (DataTemplate)GetValue(SelectedHeaderTemplateProperty); }
        set { SetValue(SelectedHeaderTemplateProperty, value); }
    }

    public static readonly BindableProperty SelectedHeaderTemplateProperty =
        BindableProperty.Create(
            nameof(SelectedHeaderTemplate),
            typeof(DataTemplate),
            typeof(TabView)
            );
    #endregion

    #region HeaderTemplate
    public DataTemplate HeaderTemplate
    {
        get { return (DataTemplate)GetValue(HeaderTemplateProperty); }
        set { SetValue(HeaderTemplateProperty, value); }
    }

    public static readonly BindableProperty HeaderTemplateProperty =
        BindableProperty.Create(
            nameof(HeaderTemplate),
            typeof(DataTemplate),
            typeof(TabView)
            );
    #endregion

    #region ContentTemplate
    public DataTemplate ContentTemplate
    {
        get { return (DataTemplate)GetValue(ContentTemplateProperty); }
        set { SetValue(ContentTemplateProperty, value); }
    }

    public static readonly BindableProperty ContentTemplateProperty =
        BindableProperty.Create(
            nameof(ContentTemplate),
            typeof(DataTemplate),
            typeof(TabView)
            );
    #endregion

    #region ItemsSource
    public IEnumerable ItemsSource
    {
        get { return (IEnumerable)GetValue(ItemsSourceProperty); }
        set { SetValue(ItemsSourceProperty, value); }
    }

    public static readonly BindableProperty ItemsSourceProperty =
        BindableProperty.Create(
            nameof(ItemsSource),
            typeof(IEnumerable),
            typeof(TabView)
            );
    #endregion

    #region SelectedTabChangedCommand
    public ICommand SelectedTabChangedCommand
    {
        get { return (ICommand)GetValue(SelectedTabChangedCommandProperty); }
        set { SetValue(SelectedTabChangedCommandProperty, value); }
    }

    public static readonly BindableProperty SelectedTabChangedCommandProperty =
        BindableProperty.Create(
            nameof(SelectedTabChangedCommand),
            typeof(ICommand),
            typeof(TabView)
            );
    #endregion

    #region SelectedTabChangedCommandParameter
    public object SelectedTabChangedCommandParameter
    {
        get { return (object)GetValue(SelectedTabChangedCommandParameterProperty); }
        set { SetValue(SelectedTabChangedCommandParameterProperty, value); }
    }

    public static readonly BindableProperty SelectedTabChangedCommandParameterProperty =
        BindableProperty.Create(
            nameof(SelectedTabChangedCommandParameter),
            typeof(object),
            typeof(TabView)
            );
    #endregion

    #region HeaderBarAlignment
    public Alignment HeaderBarAlignment
    {
        get { return (Alignment)GetValue(HeaderBarAlignmentProperty); }
        set { SetValue(HeaderBarAlignmentProperty, value); }
    }

    public static readonly BindableProperty HeaderBarAlignmentProperty =
        BindableProperty.Create(
            nameof(HeaderBarAlignment),
            typeof(Alignment),
            typeof(TabView),
            Alignment.Top
            );
    #endregion

    // Новое свойство: как выравнивать заголовок по вертикали
    public LayoutOptions HeaderItemVerticalOptions
    {
        get => (LayoutOptions)GetValue(HeaderItemVerticalOptionsProperty);
        set => SetValue(HeaderItemVerticalOptionsProperty, value);
    }

    public static readonly BindableProperty HeaderItemVerticalOptionsProperty =
        BindableProperty.Create(
            nameof(HeaderItemVerticalOptions),
            typeof(LayoutOptions),
            typeof(TabView),
            LayoutOptions.Center // старая логика: по центру
        );

    // Новое свойство: как выравнивать заголовок по горизонтали (опционально)
    public LayoutOptions HeaderItemHorizontalOptions
    {
        get => (LayoutOptions)GetValue(HeaderItemHorizontalOptionsProperty);
        set => SetValue(HeaderItemHorizontalOptionsProperty, value);
    }

    public static readonly BindableProperty HeaderItemHorizontalOptionsProperty =
        BindableProperty.Create(
            nameof(HeaderItemHorizontalOptions),
            typeof(LayoutOptions),
            typeof(TabView),
            LayoutOptions.Center
        );
}

Файл: PipeProfileAppMaui\MPowerKit.TabView\TabViewHeaderItem.cs
using System.Runtime.CompilerServices;

namespace MPowerKit.TabView;

public class TabViewHeaderItem : Grid
{
    protected readonly DataTemplate StringTemplate = new(() =>
    {
        var lbl = new Label()
        {
            VerticalOptions = LayoutOptions.Center,
            HorizontalOptions = LayoutOptions.Center,
            VerticalTextAlignment = TextAlignment.Center,
            HorizontalTextAlignment = TextAlignment.Center
        };
        lbl.SetBinding(Label.TextProperty, ".");
        lbl.SetBinding(Label.TextColorProperty, new Binding(TabView.HeaderTextColorProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        lbl.SetBinding(Label.FontFamilyProperty, new Binding(TabView.HeaderFontFamilyProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        lbl.SetBinding(Label.FontSizeProperty, new Binding(TabView.HeaderFontSizeProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        lbl.SetBinding(Label.FontAttributesProperty, new Binding(TabView.HeaderFontAttributesProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        return new ContentView()
        {
            Content = lbl,
            VerticalOptions = LayoutOptions.Fill,
            HorizontalOptions = LayoutOptions.Fill,
            Padding = new Thickness(20, 10)
        };
    });

    protected View? SelectedView;
    protected View? UnselectedView;

    public TabViewHeaderItem()
    {
        var tap = new TapGestureRecognizer();
        tap.Tapped += Tap_Tapped;
        GestureRecognizers.Add(tap);

        SetBinding(SelectedContentTemplateProperty, new Binding(TabView.SelectedHeaderTemplateProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        SetBinding(ContentTemplateProperty, new Binding(TabView.HeaderTemplateProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        SetBinding(HideWhenDisabledProperty, new Binding(TabView.HideTabsWhenDisabledProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
		SetBinding(BackgroundColorProperty, new Binding(TabView.HeaderBackgroundColorProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));

        // Привяжем VerticalOptions и HorizontalOptions к новым свойствам TabView
        SetBinding(VerticalOptionsProperty, new Binding(
            nameof(TabView.HeaderItemVerticalOptions),
            source: RelativeBindingSource.TemplatedParent));

        SetBinding(HorizontalOptionsProperty, new Binding(
            nameof(TabView.HeaderItemHorizontalOptions),
            source: RelativeBindingSource.TemplatedParent));

    }

    private void Tap_Tapped(object? sender, EventArgs e)
    {
        if (!IsEnabled) return;

        if (!IsSelected) IsSelected = true;
    }

    protected override void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        base.OnPropertyChanged(propertyName);

        if (propertyName == HideWhenDisabledProperty.PropertyName)
        {
            IsVisible = !HideWhenDisabled || IsEnabled;
            return;
        }

        if (propertyName == HeaderContentProperty.PropertyName && HeaderContent is View content)
        {
            Children.Clear();
            Children.Add(content);
        }

        if (HeaderContent is View) return;

        else if (propertyName == IsSelectedProperty.PropertyName)
        {
            SetBinding(View.BackgroundColorProperty, new Binding(IsSelected
                ? TabView.SelectedHeaderBackgroundColorProperty.PropertyName
                : TabView.HeaderBackgroundColorProperty.PropertyName, source: RelativeBindingSource.TemplatedParent));
        }
        else if (propertyName == HeaderContentProperty.PropertyName
            || propertyName == SelectedContentTemplateProperty.PropertyName
            || propertyName == ContentTemplateProperty.PropertyName)
        {
            InitContent();
        }
    }

    public virtual void InitContent()
    {
        var unselectedTemplate = ContentTemplate != null
            ? (ContentTemplate is DataTemplateSelector selectorU ? selectorU.SelectTemplate(HeaderContent, null) : ContentTemplate)
            : StringTemplate;

        var selectedTemplate = SelectedContentTemplate != null
            ? (SelectedContentTemplate is DataTemplateSelector selectorS ? selectorS.SelectTemplate(HeaderContent, null) : SelectedContentTemplate)
            : unselectedTemplate;

        var context = HeaderContent;
        context ??= "Empty Header";

        SelectedView = selectedTemplate.CreateContent() as View;
        SelectedView!.BindingContext = selectedTemplate == StringTemplate ? context.ToString() : context;

        UnselectedView = unselectedTemplate.CreateContent() as View;
        UnselectedView!.BindingContext = unselectedTemplate == StringTemplate ? context.ToString() : context;

        SelectedView.SetBinding(View.IsVisibleProperty, new Binding(IsSelectedProperty.PropertyName, source: this));
        UnselectedView.SetBinding(View.IsVisibleProperty, new Binding(IsSelectedProperty.PropertyName, source: this, converter: new InverseBooleanConverter()));

        Children.Clear();
        Children.Add(SelectedView);
        Children.Add(UnselectedView);
    }

    #region IsSelected
    public bool IsSelected
    {
        get { return (bool)GetValue(IsSelectedProperty); }
        set { SetValue(IsSelectedProperty, value); }
    }

    public static readonly BindableProperty IsSelectedProperty =
        BindableProperty.Create(
            nameof(IsSelected),
            typeof(bool),
            typeof(TabViewHeaderItem)
            );
    #endregion

    #region HeaderContent
    public object HeaderContent
    {
        get { return (object)GetValue(HeaderContentProperty); }
        set { SetValue(HeaderContentProperty, value); }
    }

    public static readonly BindableProperty HeaderContentProperty =
        BindableProperty.Create(
            nameof(HeaderContent),
            typeof(object),
            typeof(TabViewHeaderItem)
            );
    #endregion

    #region SelectedContentTemplate
    public DataTemplate SelectedContentTemplate
    {
        get { return (DataTemplate)GetValue(SelectedContentTemplateProperty); }
        set { SetValue(SelectedContentTemplateProperty, value); }
    }

    public static readonly BindableProperty SelectedContentTemplateProperty =
        BindableProperty.Create(
            nameof(SelectedContentTemplate),
            typeof(DataTemplate),
            typeof(TabViewHeaderItem)
            );
    #endregion

    #region ContentTemplate
    public DataTemplate ContentTemplate
    {
        get { return (DataTemplate)GetValue(ContentTemplateProperty); }
        set { SetValue(ContentTemplateProperty, value); }
    }

    public static readonly BindableProperty ContentTemplateProperty =
        BindableProperty.Create(
            nameof(ContentTemplate),
            typeof(DataTemplate),
            typeof(TabViewHeaderItem)
            );
    #endregion

    #region HideWhenDisabled
    public bool HideWhenDisabled
    {
        get { return (bool)GetValue(HideWhenDisabledProperty); }
        set { SetValue(HideWhenDisabledProperty, value); }
    }

    public static readonly BindableProperty HideWhenDisabledProperty =
        BindableProperty.Create(
            nameof(HideWhenDisabled),
            typeof(bool),
            typeof(TabViewHeaderItem),
            true
            );
    #endregion
}

Файл: PipeProfileAppMaui\MPowerKit.TabView\TabViewItem.cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace MPowerKit.TabView;

public class TabViewItem : ContentView
{
    public TabViewHeaderItem TabViewHeaderItem { get; protected set; } = [];

    public TabViewItem()
    {
        TabViewHeaderItem.PropertyChanged += TabViewHeaderItem_PropertyChanged;

        SetBinding(IsVisibleProperty, new Binding(IsSelectedProperty.PropertyName, source: this));
        TabViewHeaderItem.SetBinding(View.IsEnabledProperty, new Binding(IsEnabledProperty.PropertyName, mode: BindingMode.TwoWay, source: this));
        TabViewHeaderItem.SetBinding(TabViewHeaderItem.HeaderContentProperty, new Binding(HeaderProperty.PropertyName, source: this));
        TabViewHeaderItem.SetBinding(Grid.ColumnProperty, new Binding(ColumnProperty.PropertyName, source: this));
        TabViewHeaderItem.SetBinding(Grid.RowProperty, new Binding(RowProperty.PropertyName, source: this));
    }

    private void TabViewHeaderItem_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == TabViewHeaderItem.IsSelectedProperty.PropertyName)
        {
            IsSelected = TabViewHeaderItem.IsSelected;
        }
    }

    protected override void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        base.OnPropertyChanged(propertyName);

        if (propertyName == IsEnabledProperty.PropertyName
            || propertyName == IsSelectedProperty.PropertyName
            && !IsEnabled && IsSelected)
        {
            IsSelected = false;
        }

        if (propertyName == IsSelectedProperty.PropertyName)
        {
            TabViewHeaderItem.IsSelected = IsSelected;
        }
    }

    #region IsSelected
    public bool IsSelected
    {
        get { return (bool)GetValue(IsSelectedProperty); }
        set { SetValue(IsSelectedProperty, value); }
    }

    public static readonly BindableProperty IsSelectedProperty =
        BindableProperty.Create(
            nameof(IsSelected),
            typeof(bool),
            typeof(TabViewItem)
            );
    #endregion

    #region Header
    public object Header
    {
        get { return (object)GetValue(HeaderProperty); }
        set { SetValue(HeaderProperty, value); }
    }

    public static readonly BindableProperty HeaderProperty =
        BindableProperty.Create(
            nameof(Header),
            typeof(object),
            typeof(TabViewItem)
            );
    #endregion

    #region Column
    public int Column
    {
        get { return (int)GetValue(ColumnProperty); }
        set { SetValue(ColumnProperty, value); }
    }

    public static readonly BindableProperty ColumnProperty =
        BindableProperty.Create(
            nameof(Column),
            typeof(int),
            typeof(TabViewItem)
            );
    #endregion

    #region Row
    public int Row
    {
        get { return (int)GetValue(RowProperty); }
        set { SetValue(RowProperty, value); }
    }

    public static readonly BindableProperty RowProperty =
        BindableProperty.Create(
            nameof(Row),
            typeof(int),
            typeof(TabViewItem)
            );
    #endregion
}

Файл: PipeProfileAppMaui\MPowerKit.TabView\TabViewStyle.xaml
<?xml version="1.0" encoding="utf-8" ?>
<ResourceDictionary x:Class="MPowerKit.TabView.TabViewStyle"
                    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
                    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
                    xmlns:controls="clr-namespace:MPowerKit.TabView">

    <Style TargetType="controls:TabView">
        <Setter Property="Padding"
                Value="0" />
        <Setter Property="Margin"
                Value="0" />
        <Setter Property="ControlTemplate">
            <Setter.Value>
                <ControlTemplate>
                    <Grid ColumnSpacing="0"
                          RowSpacing="0">
                        <Grid.Triggers>
                            <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="Grid"
                                         Value="Top">
                                <Setter Property="RowDefinitions"
                                        Value="Auto,*" />
                                <Setter Property="ColumnDefinitions"
                                        Value="*" />
                            </DataTrigger>
                            <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="Grid"
                                         Value="Bottom">
                                <Setter Property="RowDefinitions"
                                        Value="*,Auto" />
                                <Setter Property="ColumnDefinitions"
                                        Value="*" />
                            </DataTrigger>
                            <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="Grid"
                                         Value="Left">
                                <Setter Property="RowDefinitions"
                                        Value="*" />
                                <Setter Property="ColumnDefinitions"
                                        Value="Auto,*" />
                            </DataTrigger>
                            <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="Grid"
                                         Value="Right">
                                <Setter Property="RowDefinitions"
                                        Value="*" />
                                <Setter Property="ColumnDefinitions"
                                        Value="*,Auto" />
                            </DataTrigger>
                        </Grid.Triggers>
                        <ScrollView x:Name="PART_HeadersScrollView"
                                    Margin="{TemplateBinding Padding}"
                                    BackgroundColor="{TemplateBinding HeaderBarBackgroundColor}"
                                    HorizontalOptions="Fill"
                                    HorizontalScrollBarVisibility="Never"
                                    VerticalOptions="Fill"
                                    VerticalScrollBarVisibility="Never">
                            <ScrollView.Triggers>
                                <!-- Горизонтальная шапка сверху -->
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="ScrollView"
                                         Value="Top">
                                    <Setter Property="Orientation" Value="Horizontal" />
                                    <Setter Property="Grid.Row" Value="0" />
                                    <Setter Property="Grid.Column" Value="0" />
                                    <Setter Property="HeightRequest" Value="{TemplateBinding HeaderHeightRequest}" />
                                </DataTrigger>

                                <!-- Горизонтальная шапка снизу -->
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="ScrollView"
                                         Value="Bottom">
                                    <Setter Property="Orientation" Value="Horizontal" />
                                    <Setter Property="Grid.Row" Value="1" />
                                    <Setter Property="Grid.Column" Value="0" />
                                    <Setter Property="HeightRequest" Value="{TemplateBinding HeaderHeightRequest}" />
                                </DataTrigger>

                                <!-- Вертикальная панель слева -->
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="ScrollView"
                                         Value="Left">
                                    <Setter Property="Orientation" Value="Vertical" />
                                    <Setter Property="Grid.Row" Value="0" />
                                    <Setter Property="Grid.Column" Value="0" />
                                    <Setter Property="WidthRequest" Value="{TemplateBinding HeaderHeightRequest}" />
                                </DataTrigger>

                                <!-- Вертикальная панель справа -->
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                         TargetType="ScrollView"
                                         Value="Right">
                                    <Setter Property="Orientation" Value="Vertical" />
                                    <Setter Property="Grid.Row" Value="0" />
                                    <Setter Property="Grid.Column" Value="1" />
                                    <Setter Property="WidthRequest" Value="{TemplateBinding HeaderHeightRequest}" />
                                </DataTrigger>
                            </ScrollView.Triggers>

                            <controls:ItemsPresenter />
                        </ScrollView>
                        <Grid x:Name="PART_ContentContainer"
                              Grid.Row="1"
                              Margin="{TemplateBinding Padding}"
                              BackgroundColor="{TemplateBinding ContentBackgroundColor}">
                            <Grid.Triggers>
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                             TargetType="Grid"
                                             Value="Top">
                                    <Setter Property="Grid.Row"
                                            Value="1" />
                                    <Setter Property="Grid.Column"
                                            Value="0" />
                                </DataTrigger>
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                             TargetType="Grid"
                                             Value="Bottom">
                                    <Setter Property="Grid.Row"
                                            Value="0" />
                                    <Setter Property="Grid.Column"
                                            Value="0" />
                                </DataTrigger>
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                             TargetType="Grid"
                                             Value="Left">
                                    <Setter Property="Grid.Row"
                                            Value="0" />
                                    <Setter Property="Grid.Column"
                                            Value="1" />
                                </DataTrigger>
                                <DataTrigger Binding="{TemplateBinding HeaderBarAlignment}"
                                             TargetType="Grid"
                                             Value="Right">
                                    <Setter Property="Grid.Row"
                                            Value="0" />
                                    <Setter Property="Grid.Column"
                                            Value="0" />
                                </DataTrigger>
                            </Grid.Triggers>
                        </Grid>
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>

Файл: PipeProfileAppMaui\MPowerKit.TabView\TabViewStyle.xaml.cs
namespace MPowerKit.TabView;

public partial class TabViewStyle
{
    public TabViewStyle()
    {
        InitializeComponent();
    }
}

Файл: PipeProfileAppMaui\Services\GroundCurveRenderer.cs
// File: Services/GroundCurveRenderer.cs
using System.Collections.Generic;
using SkiaSharp;
using PipeProfileAppMaui.Helpers;
using PipeProfileAppMaui.Models;

namespace PipeProfileAppMaui.Services
{
    /// <summary>
    /// Рисует ломаную грунта и над ключевыми точками
    /// подписывает разницу высоты относительно первой точки.
    /// </summary>
    public class GroundCurveRenderer
    {
        readonly SKPaint _linePaint = new()
        {
            Style = SKPaintStyle.Stroke,
            Color = SKColors.Brown,
            StrokeWidth = 2,
            IsAntialias = true
        };

        readonly SKPaint _circlePaint = new()
        {
            Style = SKPaintStyle.Fill,
            Color = SKColors.Red,
            IsAntialias = true
        };

        readonly SKPaint _textPaint = new()
        {
            Style = SKPaintStyle.Fill,
            Color = SKColors.Black,
            TextSize = 12,
            IsAntialias = true
        };

        /// <summary>
        /// Рисует грунтовую ломаную и подписывает Δ высоты над первой точкой.
        /// </summary>
        public void Render(
            SKCanvas canvas,
            SKMatrix worldToDev,
            IReadOnlyList<GroundPoint> groundPoints,
            bool showMarkers)
        {
            if (groundPoints.Count < 1)
                return;

            // 1) Построить и отрисовать ломаную грунта
            var path = new SKPath();
            for (int i = 0; i < groundPoints.Count; i++)
            {
                var gp = groundPoints[i];
                var worldPt = new SKPoint(
                    (float)gp.Distance_m,
                    (float)gp.Elevation_cm);

                if (i == 0) path.MoveTo(worldPt);
                else path.LineTo(worldPt);
            }

            using var devPath = new SKPath();
            path.Transform(worldToDev, devPath);
            canvas.DrawPath(devPath, _linePaint);

            // высота первой точки
            float baseElev = (float)groundPoints[0].Elevation_cm;

            // 2) В опорных точках – кружки + подписи
            foreach (var gp in groundPoints)
            {
                var worldPt = new SKPoint(
                    (float)gp.Distance_m,
                    (float)gp.Elevation_cm);

                // device‐координата
                var devPt = worldToDev.MapPoint(worldPt);

                // рисуем кружок
                 const float R = 4f;
               if (showMarkers) canvas.DrawCircle(devPt, R, _circlePaint);

                // вычисляем дельту высоты
                float delta = (float)(gp.Elevation_cm - baseElev) / 100;
                string text = $"{delta:F2}";

                // точка над кружком
                var textPos = new SKPoint(
                    devPt.X,
                    devPt.Y - R - 4); // 4px отступ

                // рисуем текст по центру X
                TextDrawingHelper.DrawTextAbovePoint(canvas, devPt, text, 7);
            }
        }
    }
}

Файл: PipeProfileAppMaui\Services\IPipeRenderer.cs
using SkiaSharp;
using System.Collections.ObjectModel;
using PipeProfileAppMaui.Models;
using SkiaSharp.Views.Maui.Controls;

namespace PipeProfileAppMaui.Services
{
    public interface IPipeRenderer
    {
        /// <summary>
        /// Рисует профиль внутри area. ground/pipe передаются из VM.
        /// </summary>
        void Render(
          SKCanvas canvas,
          SKRect profileArea,
          IReadOnlyList<GroundPoint> groundPoints,
          IReadOnlyList<PipePoint> pipePoints,
          Func<double, double> interpolateGroundElevation);
    }
}

Файл: PipeProfileAppMaui\Services\PipeCenterlineRenderer.cs
// File: Services/PipeCenterlineRenderer.cs
using System;
using System.Collections.Generic;
using System.Linq;
using SkiaSharp;
using PipeProfileAppMaui.Models;

namespace PipeProfileAppMaui.Services
{
    /// <summary>
    /// Рисует штриховую центральную осевую линию внутри трубы
    /// от заданного старта до конца трубы.
    /// </summary>
    public class PipeCenterlineRenderer
    {
        private readonly SKPaint _dashPaint;

        /// <param name="dashPattern">
        /// Массив длины штриха и длины пробела, например {4,4}
        /// </param>
        public PipeCenterlineRenderer(float[] dashPattern)
        {
            _dashPaint = new SKPaint
            {
                Style = SKPaintStyle.Stroke,
                Color = SKColors.DarkBlue,
                StrokeWidth = 1,
                IsAntialias = true,
                PathEffect = SKPathEffect.CreateDash(dashPattern, 0)
            };
        }

        /// <summary>
        /// Отрисовка осевой штриховой линии.
        /// </summary>
        public void Render(
            SKCanvas canvas,
            SKMatrix worldToDev,
            IReadOnlyList<PipePoint> pipePoints,
            Func<double, double> interpElevation,
            double startOffset_m,
            double totalLength_m)
        {
            if (pipePoints.Count < 2)
                return;

            // 1) Собираем мировые точки от start до end
            double start = pipePoints[0].Distance_m + startOffset_m;
            double end = start + totalLength_m;

            var axisPts = pipePoints
                .Where(p => p.Distance_m >= start && p.Distance_m <= end)
                .Select(p => new SKPoint(
                    (float)p.Distance_m,
                    (float)(interpElevation(p.Distance_m) - p.Depth_cm)))
                .ToArray();

            if (axisPts.Length < 2)
                return;

            // 2) Строим сглаженный путь по Catmull–Rom → Bezier
            using var worldPath = PipeTangentRenderer
                .BuildSmoothPipePath(axisPts);

            // 3) Преобразуем в экранные координаты
            using var devPath = new SKPath();
            worldPath.Transform(worldToDev, devPath);

            // 4) Рисуем штриховой отрезок по всему пути
            canvas.DrawPath(devPath, _dashPaint);
        }
    }
}

Файл: PipeProfileAppMaui\Services\PipeCurveRenderer.cs
// File: Services/PipeCurveRenderer.cs
using SkiaSharp;
using PipeProfileAppMaui.Models;

namespace PipeProfileAppMaui.Services
{
    /// <summary>
    /// Рисует сглаженную кривую трубы (Catmull–Rom → Cubic Bezier).
    /// </summary>
    public class PipeCurveRenderer
    {
        private readonly SKPaint _paint = new SKPaint
        {
            Style = SKPaintStyle.Stroke,
            Color = SKColors.Blue,
            StrokeWidth = 3,
            IsAntialias = true
        };

        private readonly Func<double, double> _interpolateGroundElevation;

        public PipeCurveRenderer(Func<double, double> interpolateGroundElevation)
        {
            _interpolateGroundElevation = interpolateGroundElevation;
        }

        public void Render(
            SKCanvas canvas,
            SKMatrix worldToDev,
            IReadOnlyList<PipePoint> pipePoints,
            Func<double, double> interpElevation)
        {
            if (pipePoints.Count < 2)
                return;

            // 1) Подготовить «мировые» точки трубы
            var worldPts = pipePoints
                .Select(p => new SKPoint(
                    (float)p.Distance_m,
                    (float)(interpElevation(p.Distance_m) - p.Depth_cm)))
                .ToList();

            // 2) Построить сглаженный путь с корректной начальной касательной
            using var worldPath = PipeTangentRenderer.BuildSmoothPipePath(worldPts.ToArray());

            // 3) Преобразовать путь в device‐координаты
            using var devPath = new SKPath();
            worldPath.Transform(worldToDev, devPath);

            // 4) Нарисовать
            canvas.DrawPath(devPath, _paint);
        }

    }
}

Файл: PipeProfileAppMaui\Services\PipeProfileRenderer.cs
using SkiaSharp;
using PipeProfileAppMaui.ViewModels;
using PipeProfileAppMaui.Models;
using System.Collections.ObjectModel;
using SkiaSharp.Views.Maui.Controls;

namespace PipeProfileAppMaui.Services
{
    public class PipeProfileRenderer
    {
        private MainViewModel _viewModel;

        // Параметры трансформации
        public float Zoom { get; set; } = 1f;
        public float PanX { get; set; } = 0f;
        public float PanY { get; set; } = 0f;
        public bool ShowPointNumbers { get; set; } = false;

        // Конструктор c опциональным viewModel
        public PipeProfileRenderer(
            SKCanvas canvas,
            SKRect profileRect,                      // область на экране (px)
            IReadOnlyList<GroundPoint> groundPoints, // в мм
            IReadOnlyList<PipePoint> pipePoints,     // в мм
            Func<double, double> interpElevation)
        {
            if (groundPoints.Count < 2 || pipePoints.Count < 1)
                return;

            // 1) Находим мир-диапазоны по X (rast) и по Y (от minElevation–minDepth до maxElevation)
            float minX = (float)groundPoints.Min(p => p.Distance_m);
            float maxX = (float)groundPoints.Max(p => p.Distance_m);
            float spanX = maxX - minX;

            // по Y: берем уровень грунта и трубу, чтобы вместить обе линии
            float minGround = (float)groundPoints.Min(p => p.Elevation_cm);
            float maxGround = (float)groundPoints.Max(p => p.Elevation_cm);
            float minPipe = pipePoints
                              .Select(pp => (float)(interpElevation(pp.Distance_m) - pp.Depth_cm))
                              .Min();
            float maxPipe = pipePoints
                              .Select(pp => (float)(interpElevation(pp.Distance_m) - pp.Depth_cm))
                              .Max();

            float minY = Math.Min(minGround, minPipe);
            float maxY = Math.Max(maxGround, maxPipe);
            float spanY = maxY - minY;

            if (spanX <= 0 || spanY <= 0)
                return;

            // 2) Вычисляем шкалу «мм → пиксели» одинаково по обеим осям,
            //    чтобы профиль не искажался.
            float scaleX = profileRect.Width / spanX;
            float scaleY = profileRect.Height / spanY;
            float scale = Math.Min(scaleX, scaleY);

            // 3) Сдвиги: (distance–minX)*scale + profileRect.Left
            //    Y: (elevation–minY)*scale → Y-пиксели от низа области
            float ox = profileRect.Left;
            float oy = profileRect.Bottom;

            // 4) Клипуем рисунок строго профильно
            canvas.Save();
            canvas.ClipRect(profileRect);

            // 5) Рисуем грунт
            using var paintG = new SKPaint
            {
                Style = SKPaintStyle.Stroke,
                Color = SKColors.Brown,
                StrokeWidth = 2,
                IsAntialias = true
            };
            var pathG = new SKPath();
            for (int i = 0; i < groundPoints.Count; i++)
            {
                float x = ox + (float)(groundPoints[i].Distance_m - minX) * scale;
                float y = oy - ((float)groundPoints[i].Elevation_cm - minY) * scale;
                if (i == 0) pathG.MoveTo(x, y);
                else pathG.LineTo(x, y);
            }
            canvas.DrawPath(pathG, paintG);

            // 6) Рисуем трубу
            using var paintP = new SKPaint
            {
                Style = SKPaintStyle.Stroke,
                Color = SKColors.Blue,
                StrokeWidth = 3,
                IsAntialias = true
            };
            var pathP = new SKPath();
            for (int i = 0; i < pipePoints.Count; i++)
            {
                float dist = (float)pipePoints[i].Distance_m;
                float elev = (float)(interpElevation(dist) - pipePoints[i].Depth_cm);
                float x = ox + (dist - minX) * scale;
                float y = oy - (elev - minY) * scale;
                if (i == 0) pathP.MoveTo(x, y);
                else pathP.LineTo(x, y);
            }
            canvas.DrawPath(pathP, paintP);

            canvas.Restore();
        }

        // Позволяет передать или обновить ViewModel
        public void SetViewModel(MainViewModel viewModel)
        {
            _viewModel = viewModel;
        }

        public void Draw(
            SKCanvas canvas,
            int width,
            int height,
            ObservableCollection<GroundPoint> groundPoints,
            ObservableCollection<PipePoint> pipePoints,
            float zoomLevel,
            SKPoint panOffset)
        {
            if (_viewModel == null) return;

            canvas.Clear(SKColors.White);
            canvas.Save();

            // Трансформация
            canvas.Translate(PanX, PanY);
            canvas.Scale(Zoom);

            // Рисуем грунт (ломаная)
            if (_viewModel.GroundVm.GroundPoints.Count >= 2)
            {
                using var paintG = new SKPaint { Color = SKColors.Brown, StrokeWidth = 3, IsStroke = true };
                var pathG = new SKPath();
                for (int i = 0; i < _viewModel.GroundVm.GroundPoints.Count; i++)
                {
                    var p = _viewModel.GroundVm.GroundPoints[i];
                    float x = (float)(p.Distance_m * 5);
                    float y = (float)(height - p.Elevation_cm * 2);
                    if (i == 0) pathG.MoveTo(x, y);
                    else pathG.LineTo(x, y);
                }
                canvas.DrawPath(pathG, paintG);
            }

            // Рисуем трубу (кривые Безье)
            if (_viewModel.PipeVm.PipePoints.Count >= 3)
            {
                var screenPoints = new List<SKPoint>();
                foreach (var p in _viewModel.PipeVm.PipePoints)
                {
                    float x = (float)(p.Distance_m * 5);
                    float groundElev = InterpolateGroundElevation(p.Distance_m);
                    float y = (float)(height - (groundElev - p.Depth_cm) * 2);
                    screenPoints.Add(new SKPoint(x, y));
                }

                using var paintP = new SKPaint { Color = SKColors.Blue, StrokeWidth = 4, IsStroke = true, IsAntialias = true };
                var pathP = new SKPath();
                pathP.MoveTo(screenPoints[0]);

                for (int i = 0; i < screenPoints.Count - 1; i++)
                {
                    var p1 = screenPoints[i];
                    var p2 = screenPoints[i + 1];
                    var c1 = new SKPoint((p1.X + p2.X) / 2, p1.Y);
                    var c2 = new SKPoint((p1.X + p2.X) / 2, p2.Y);
                    pathP.CubicTo(c1, c2, p2);
                }
                canvas.DrawPath(pathP, paintP);

                // Касательные каждые 30px
                var measure = new SKPathMeasure(pathP, false);
                float len = measure.Length;
                var tanPaint = new SKPaint { Color = SKColors.Red, StrokeWidth = 2 };
                var textPaint = new SKPaint { Color = SKColors.Black, TextSize = 12 / Zoom, IsAntialias = true };

                for (float d = 0; d < len; d += 30)
                {
                    if (measure.GetPositionAndTangent(d, out var pos, out var tan))
                    {
                        float l = SKPoint.Distance(new SKPoint(0, 0), tan);
                        var unit = new SKPoint(tan.X / l, tan.Y / l);
                        var end = new SKPoint(pos.X + unit.X * 10, pos.Y + unit.Y * 10);
                        canvas.DrawLine(pos, end, tanPaint);

                        double distanceAt = pos.X / 5f;
                        float groundElev = InterpolateGroundElevation(distanceAt);
                        float pipeElev = (height - pos.Y) / 2f;
                        float depthAt = groundElev - pipeElev;

                        var angleTan = unit.Y / unit.X;
                        canvas.DrawText($"tan={angleTan:F2}", end.X + 5, end.Y - 5, textPaint);
                        canvas.DrawText($"глуб={depthAt:F2}", end.X + 5, end.Y + 10, textPaint);
                    }
                }
            }

            // Номера точек
            if (ShowPointNumbers)
            {
                using var numPaint = new SKPaint { Color = SKColors.Black, TextSize = 14 / Zoom, IsAntialias = true };
                for (int i = 0; i < _viewModel.PipeVm.PipePoints.Count; i++)
                {
                    var p = _viewModel.PipeVm.PipePoints[i];
                    float x = (float)(p.Distance_m * 5);
                    float groundElev = InterpolateGroundElevation(p.Distance_m);
                    float y = (float)(height - (groundElev - p.Depth_cm) * 2);
                    canvas.DrawText((i + 1).ToString(), x + 5 / Zoom, y - 5 / Zoom, numPaint);
                }
                for (int i = 0; i < _viewModel.GroundVm.GroundPoints.Count; i++)
                {
                    var gp = _viewModel.GroundVm.GroundPoints[i];
                    float x = (float)(gp.Distance_m * 5);
                    float y = (float)(canvas.TotalMatrix.ScaleY * (height - gp.Elevation_cm * 2));
                    canvas.DrawText((i + 1).ToString(), x + (5 / Zoom), y - 5 / Zoom, numPaint);
                }
            }

            canvas.Restore();
        }

        private float InterpolateGroundElevation(double distance)
        {
            var pts = _viewModel.GroundVm.GroundPoints;
            if (pts.Count == 0) return 0;
            if (distance <= pts[0].Distance_m) return (float)pts[0].Elevation_cm;
            if (distance >= pts[^1].Distance_m) return (float)pts[^1].Elevation_cm;
            for (int i = 0; i < pts.Count - 1; i++)
            {
                if (distance >= pts[i].Distance_m && distance <= pts[i + 1].Distance_m)
                {
                    float d0 = (float)pts[i].Distance_m;
                    float d1 = (float)pts[i + 1].Distance_m;
                    float e0 = (float)pts[i].Elevation_cm;
                    float e1 = (float)pts[i + 1].Elevation_cm;
                    float t = (float)((distance - d0) / (d1 - d0));
                    return e0 + t * (e1 - e0);
                }
            }
            return (float)pts[^1].Elevation_cm;
        }
    }
}

Файл: PipeProfileAppMaui\Services\PipeShapeRenderer.cs
// File: Services/PipeShapeRenderer.cs
using System;
using System.Collections.Generic;
using System.Linq;
using SkiaSharp;
using PipeProfileAppMaui.Models;

namespace PipeProfileAppMaui.Services
{
    public class PipeShapeRenderer
    {
        private readonly double _startOffset;
        private readonly double _totalLength;
        private readonly float _diameterCm;
        private readonly SKPaint _paint = new()
        {
            Style = SKPaintStyle.Stroke,
            Color = SKColors.Blue,
            StrokeWidth = 2,
            IsAntialias = true
        };

        public PipeShapeRenderer(double startOffset_m,
                                 double totalLength_m,
                                 float diameter_cm)
        {
            _startOffset = startOffset_m;
            _totalLength = totalLength_m;
            _diameterCm = diameter_cm;
        }

        public void Render(
            SKCanvas canvas,
            SKMatrix worldToDev,
            IReadOnlyList<PipePoint> pipePoints,
            Func<double, double> interpElevation)
        {
            if (pipePoints.Count < 2)
                return;

            // 1) строим осевые точки в world-координатах
            var axisPts = BuildAxisPoints(pipePoints, interpElevation);
            if (axisPts.Count < 2)
                return;

            // 2) смещение вверх/вниз на радиус
            float r = _diameterCm / 2f;
            var upper = axisPts.Select(p => new SKPoint(p.X, p.Y + r)).ToArray();
            var lower = axisPts.Select(p => new SKPoint(p.X, p.Y - r)).ToArray();

            // 3) строим smoothed-paths
            using var worldUp = PipeTangentRenderer.BuildSmoothPipePath(upper);
            using var worldDn = PipeTangentRenderer.BuildSmoothPipePath(lower);
            using var devUp = new SKPath();
            using var devDn = new SKPath();

            worldUp.Transform(worldToDev, devUp);
            worldDn.Transform(worldToDev, devDn);

            // 4) рисуем границы
            canvas.DrawPath(devUp, _paint);
            canvas.DrawPath(devDn, _paint);

            // 5) получаем начала и концы через PathMeasure
            var measUp = new SKPathMeasure(devUp, false);
            var measDn = new SKPathMeasure(devDn, false);

            measUp.GetPositionAndTangent(0, out var upStart, out _);
            measDn.GetPositionAndTangent(0, out var dnStart, out _);
            measUp.GetPositionAndTangent(measUp.Length, out var upEnd, out _);
            measDn.GetPositionAndTangent(measDn.Length, out var dnEnd, out _);

            // 6) соединяем вертикальными линиями
            canvas.DrawLine(upStart, dnStart, _paint);
            canvas.DrawLine(upEnd, dnEnd, _paint);
        }

        private List<SKPoint> BuildAxisPoints(
            IReadOnlyList<PipePoint> pts,
            Func<double, double> interpElevation)
        {
            double start = pts[0].Distance_m + _startOffset;
            double end = start + _totalLength;

            return pts
                .Where(p => p.Distance_m >= start && p.Distance_m <= end)
                .Select(p => new SKPoint(
                    (float)p.Distance_m,
                    (float)(interpElevation(p.Distance_m) - p.Depth_cm)))
                .ToList();
        }
    }
}

Файл: PipeProfileAppMaui\Services\PipeTangentRenderer.cs
// File: Services/PipeTangentRenderer.cs
using System;
using System.Collections.Generic;
using System.Linq;
using SkiaSharp;
using PipeProfileAppMaui.Helpers;
using PipeProfileAppMaui.Models;

namespace PipeProfileAppMaui.Services
{
    public class PipeTangentRenderer
    {
        readonly Func<double, double> _interpElevation;
        readonly SKPaint _circlePaint = new()
        {
            Style = SKPaintStyle.Fill,
            Color = SKColors.Red,
            IsAntialias = true
        };
        readonly SKPaint _squarePaint = new()
        {
            Style = SKPaintStyle.Fill,
            Color = SKColors.Yellow,
            IsAntialias = true
        };
        readonly SKPaint _tangentPaint = new()
        {
            Style = SKPaintStyle.Stroke,
            Color = SKColors.DarkBlue,
            StrokeWidth = 2,
            IsAntialias = true
        };
        readonly SKPaint _textPaint = new()
        {
            Color = SKColors.Black,
            TextSize = 12,
            IsAntialias = true
        };

        public PipeTangentRenderer(Func<double, double> interpElevation)
            => _interpElevation = interpElevation;

        public void Render(
            SKCanvas canvas,
            SKMatrix worldToDev,
            IReadOnlyList<PipePoint> pipePoints,
            bool showMarkers)
        {
            if (pipePoints.Count < 1)
                return;

            // 1) Мировые опорные точки
            var wPts = pipePoints
                .Select(p => new SKPoint(
                    (float)p.Distance_m,
                    (float)(_interpElevation(p.Distance_m) - p.Depth_cm)))
                .ToArray();

            // 2) Красные кружки на ключевых точках
            if (showMarkers)
            {
                foreach (var w in wPts)
                {
                    var d = worldToDev.MapPoint(w);
                    canvas.DrawCircle(d, 5f, _circlePaint);
                }
            }

            // 3) Построить и превратить путь
            using var worldPath = BuildSmoothPipePath(wPts);
            using var devPath = new SKPath();
            worldPath.Transform(worldToDev, devPath);

            // 4) Обратная матрица
            worldToDev.TryInvert(out var devToWorld);
            var meas = new SKPathMeasure(devPath, false);

            // 5) Рисуем касательные
            float step = 30f, tanLen = 10f;
            for (float dist = 0; dist < meas.Length; dist += step)
            {
                if (!meas.GetPositionAndTangent(dist, out var pos, out var tan))
                    continue;

                // жёлтый квадратик
                const float h = 4f;
                var sq = new SKRect(
                    pos.X - h, pos.Y - h,
                    pos.X + h, pos.Y + h);
                if (showMarkers) canvas.DrawRect(sq, _squarePaint);

                // синяя касательная
                float L = SKPoint.Distance(new SKPoint(), tan);
                var unit = new SKPoint(tan.X / L, tan.Y / L);
                var end = new SKPoint(
                    pos.X + unit.X * tanLen,
                    pos.Y + unit.Y * tanLen);
                canvas.DrawLine(pos, end, _tangentPaint);

                // подписи над и под квадратиком
                var wp = devToWorld.MapPoint(pos);
                double slope = unit.Y / unit.X;
                double depth = _interpElevation(wp.X) - wp.Y;

                // TextDrawingHelper.DrawText(canvas, text, location, paint)
                var above = new SKPoint(sq.MidX, sq.Top - 2);
                var below = new SKPoint(sq.MidX, sq.Bottom + _textPaint.FontSpacing + 2);
                // draw above square
                TextDrawingHelper.DrawTextAbovePoint(canvas, pos, $"{slope:F2}", 8);

                // draw below square
                TextDrawingHelper.DrawTextBelowPoint(canvas, pos, $"{depth:F2}", 8);
            }
        }

        /// <summary>
        /// Centripetal Catmull–Rom → Cubic Bezier без жёстких «i==0» веток.
        /// </summary>
        public static SKPath BuildSmoothPipePath(SKPoint[] pts)
        {
            var path = new SKPath();
            int n = pts.Length;
            if (n == 0) return path;
            if (n == 1)
            {
                path.MoveTo(pts[0]);
                return path;
            }

            // 1) Вычислить параметры t[i] по хорд-длине (α=0.5)
            double[] t = new double[n];
            t[0] = 0;
            for (int i = 1; i < n; i++)
            {
                double dx = pts[i].X - pts[i - 1].X;
                double dy = pts[i].Y - pts[i - 1].Y;
                t[i] = t[i - 1] + Math.Pow(Math.Sqrt(dx * dx + dy * dy), 0.5);
            }

            // 2) Построить путь
            path.MoveTo(pts[0]);
            for (int i = 0; i < n - 1; i++)
            {
                var p1 = pts[i];
                var p2 = pts[i + 1];

                // Tangents:
                SKPoint m1, m2;

                // m1
                if (i == 0)
                {
                    // одна соседняя точка: производная (p2-p1)/(t2-t1)
                    double dt = t[1] - t[0];
                    m1 = new SKPoint(
                        (float)((pts[1].X - p1.X) / dt),
                        (float)((pts[1].Y - p1.Y) / dt));
                }
                else
                {
                    double dt = t[i + 1] - t[i - 1];
                    m1 = new SKPoint(
                        (float)((pts[i + 1].X - pts[i - 1].X) / dt),
                        (float)((pts[i + 1].Y - pts[i - 1].Y) / dt));
                }

                // m2
                if (i + 1 == n - 1)
                {
                    double dt = t[n - 1] - t[n - 2];
                    m2 = new SKPoint(
                        (float)((p2.X - pts[n - 2].X) / dt),
                        (float)((p2.Y - pts[n - 2].Y) / dt));
                }
                else
                {
                    double dt = t[i + 2] - t[i];
                    m2 = new SKPoint(
                        (float)((pts[i + 2].X - pts[i].X) / dt),
                        (float)((pts[i + 2].Y - pts[i].Y) / dt));
                }

                // 3) Контрольные точки Bezier
                float dt12 = (float)(t[i + 1] - t[i]);
                var c1 = new SKPoint(p1.X + m1.X * dt12 / 3f,
                                     p1.Y + m1.Y * dt12 / 3f);
                var c2 = new SKPoint(p2.X - m2.X * dt12 / 3f,
                                     p2.Y - m2.Y * dt12 / 3f);

                path.CubicTo(c1, c2, p2);
            }

            return path;
        }
    }
}

Файл: PipeProfileAppMaui\Services\ProfileRenderer.cs
// File: Services/ProfileRenderer.cs
using System;
using System.Collections.Generic;
using System.Linq;
using SkiaSharp;
using PipeProfileAppMaui.Helpers;
using PipeProfileAppMaui.Models;
using PipeProfileAppMaui.ViewModels;

namespace PipeProfileAppMaui.Services
{
    /// <summary>
    /// Рисует «вписанный» профиль грунта и трубы, 
    /// учитывая отступы в мире.
    /// </summary>
    public class ProfileRenderer
    {
        // Отступы вокруг профиля в «мире»
        // по горизонтали — 2 метра
        private const float HorizontalMarginM = 2f;
        // по вертикали — 200 сантиметров
        private const float VerticalMarginCm = 200f;

        private readonly PipeShapeRenderer _shapeRenderer;
        private readonly PipeCenterlineRenderer _centerlineRenderer;

        public ProfileRenderer(MainViewModel vm)
        {
            double startOffset = 2.0;
            double totalLength = 40.0;
            float diameterCm = 20f;
            _shapeRenderer = new PipeShapeRenderer(startOffset, totalLength, diameterCm);
            _centerlineRenderer = new PipeCenterlineRenderer(new float[] { 4, 4 });
        }

        public void Render(
            SKCanvas canvas,
            SKRect profileArea,
            IReadOnlyList<GroundPoint> groundPoints,
            IReadOnlyList<PipePoint> pipePoints,
            Func<double, double> interpolateGroundElevation,
            bool showMarkers)
        {
            if (groundPoints.Count < 2 || pipePoints.Count < 1)
                return;

            // 1) Исходные диапазоны по X (в метрах) и по Y (в сантиметрах)
            float rawMinX = groundPoints.Min(g => (float)g.Distance_m);
            float rawMaxX = groundPoints.Max(g => (float)g.Distance_m);

            float rawMinY = Math.Min(
                groundPoints.Min(g => (float)g.Elevation_cm),
                pipePoints.Min(p =>
                    (float)(interpolateGroundElevation(p.Distance_m) - p.Depth_cm)));

            float rawMaxY = Math.Max(
                groundPoints.Max(g => (float)g.Elevation_cm),
                pipePoints.Max(p =>
                    (float)(interpolateGroundElevation(p.Distance_m) - p.Depth_cm)));

            // 2) Применяем отступы
            float minX = rawMinX - HorizontalMarginM;
            float maxX = rawMaxX + HorizontalMarginM;
            float minY = rawMinY - VerticalMarginCm;
            float maxY = rawMaxY + VerticalMarginCm;

            // 3) Матрица world→device
            var worldToDev = DrawingHelpers.ComposeWorldToArea(
                profileArea,
                minX, maxX,
                minY, maxY);

            // 4) Клип под рамку профиля
            canvas.Save();
            canvas.ClipRect(profileArea);

            // 5) Рисуем грунт
            var groundRenderer = new GroundCurveRenderer();
            groundRenderer.Render(canvas, worldToDev, groundPoints, showMarkers);

            //// 6) Рисуем трубу
            //var pipeRenderer = new PipeCurveRenderer(interpolateGroundElevation);
            //pipeRenderer.Render(
            //                    canvas,
            //                    worldToDev,
            //                    pipePoints,
            //                    interpolateGroundElevation);

            // 2) Тело трубы (границы)
            _shapeRenderer.Render(
               canvas, worldToDev, pipePoints, interpolateGroundElevation);

            // 3) Штриховая центральная линия
            _centerlineRenderer.Render(
               canvas, worldToDev, pipePoints, interpolateGroundElevation,
               startOffset_m: 2.0,
               totalLength_m: 40.0);

            // 7) Рисуем касательные с подписями
            var tangentRenderer = new PipeTangentRenderer(interpolateGroundElevation);
            tangentRenderer.Render(canvas, worldToDev, pipePoints, showMarkers);

             canvas.Restore();

           // 8) Таблица под профилем
            var tableRenderer = new ProfileTableRenderer(
                                rowHeightPx: 30f,  // высота строки
                                tableMarginPx: 10f   // зазор от profileArea
                                );
            tableRenderer.Render(
                canvas,
                profileArea,
                pipePoints,
                interpolateGroundElevation
            );

        }
    }
}

Файл: PipeProfileAppMaui\Services\ProfileTableRenderer.cs
// File: Services/ProfileTableRenderer.cs
using System;
using System.Collections.Generic;
using System.Linq;
using SkiaSharp;
using PipeProfileAppMaui.Models;

namespace PipeProfileAppMaui.Services
{
    public class ProfileTableRenderer
    {
        private const int RowsCount = 5;
        private readonly float _rowHeight;
        private readonly float _margin;

        private readonly SKPaint _framePaint = new()
        {
            Style = SKPaintStyle.Stroke,
            Color = SKColors.Black,
            StrokeWidth = 1,
            IsAntialias = true
        };
        private readonly SKPaint _textPaint = new()
        {
            Color = SKColors.Black,
            TextSize = 12,
            IsAntialias = true
        };

        private static readonly string[] _rowLabels = new[]
        {
            "Отметка поверхности",
            "Δ расстояние, м",
            "Уклон, %",
            "Отметка низа трубы",
            "Длина трассы"
        };

        public ProfileTableRenderer(float rowHeightPx, float tableMarginPx)
        {
            _rowHeight = rowHeightPx;
            _margin = tableMarginPx;
        }

        public void Render(
            SKCanvas canvas,
            SKRect profileArea,
            IReadOnlyList<PipePoint> pipePoints,
            Func<double, double> interpElevation)
        {
            int cols = pipePoints.Count;
            if (cols == 0)
                return;

            // 1) высота таблицы и её область
            float top = profileArea.Bottom + _margin;
            float height = RowsCount * _rowHeight;
            var tableRect = new SKRect(
                profileArea.Left,
                top,
                profileArea.Right,
                top + height);

            // 2) ширина левого столбца с метками
            float labelColW = _rowLabels
                .Select(t => _textPaint.MeasureText(t))
                .Max()
              + 16; // 8px padding

            // область значений
            var valueRect = new SKRect(
                tableRect.Left + labelColW,
                tableRect.Top,
                tableRect.Right,
                tableRect.Bottom);

            float valueColW = valueRect.Width / cols;

            // 3) горизонтальные линии
            for (int r = 0; r <= RowsCount; r++)
            {
                float y = tableRect.Top + r * _rowHeight;
                canvas.DrawLine(tableRect.Left, y, tableRect.Right, y, _framePaint);
            }

            // 4) вертикалки: граница меток и колонки
            canvas.DrawLine(
                tableRect.Left + labelColW,
                tableRect.Top,
                tableRect.Left + labelColW,
                tableRect.Bottom,
                _framePaint);

            for (int c = 1; c < cols; c++)
            {
                float x = valueRect.Left + c * valueColW;
                canvas.DrawLine(x, tableRect.Top, x, tableRect.Bottom - _rowHeight, _framePaint);
            }

            canvas.DrawLine(tableRect.Right, tableRect.Top, tableRect.Right, tableRect.Bottom, _framePaint);

            // 5) печатаем текст
            for (int r = 0; r < RowsCount; r++)
            {
                float y0 = tableRect.Top + r * _rowHeight;
                float y1 = y0 + _rowHeight;

                // метка слева
                var lblRect = new SKRect(
                    tableRect.Left, y0,
                    tableRect.Left + labelColW, y1);
                DrawTextCentered(canvas, _rowLabels[r], lblRect);

                if (r < RowsCount - 1)
                {
                    // колонки значений
                    var xs = pipePoints.Select(p => (float)p.Distance_m).ToArray();
                    for (int c = 0; c < cols; c++)
                    {
                        string txt = r switch
                        {
                            0 => interpElevation(xs[c]).ToString("F2"),
                            1 => c == 0 ? "" : (xs[c] - xs[c - 1]).ToString("F2"),
                            2 => c == 0
                                  ? ""
                                  : (100 * (interpElevation(xs[c]) - interpElevation(xs[c - 1]))
                                     / (xs[c] - xs[c - 1]))
                                    .ToString("F1") + "%",
                            3 => (interpElevation(xs[c]) - pipePoints[c].Depth_cm).ToString("F2"),
                            _ => ""
                        };

                        var cell = new SKRect(
                            valueRect.Left + c * valueColW, y0,
                            valueRect.Left + (c + 1) * valueColW, y1);
                        if (!string.IsNullOrEmpty(txt))
                            DrawTextCentered(canvas, txt, cell);
                    }
                }
                else
                {
                    // последняя строка: один объединённый столбец
                    var xs = pipePoints.Select(p => (float)p.Distance_m).ToArray();
                    string txt = (xs.Last() - xs.First()).ToString("F1") + " м";
                    var merged = new SKRect(
                        valueRect.Left, y0,
                        valueRect.Right, y1);
                    DrawTextCentered(canvas, txt, merged);
                }
            }
        }

        // теперь принимаем canvas как параметр
        private void DrawTextCentered(SKCanvas canvas, string text, SKRect rect)
        {
            var fm = _textPaint.FontMetrics;
            float w = _textPaint.MeasureText(text);
            float h = fm.Descent - fm.Ascent;

            float x = rect.Left + (rect.Width - w) / 2f;
            float y = rect.Top + (rect.Height - h) / 2f - fm.Ascent;

            canvas.DrawText(text, x, y, _textPaint);
        }
    }
}

Файл: PipeProfileAppMaui\Transforms\ViewTransform.cs
// Transforms/ViewTransform.cs
using SkiaSharp;

namespace PipeProfileAppMaui.Transforms
{
    public class ViewTransform
    {
        public float PanX { get; set; }
        public float PanY { get; set; }
        public float Zoom { get; set; } = 1f;

        /// <summary>
        /// Матрица Scale → Translate: p_screen = Zoom * p_world + Pan
        /// </summary>
        public SKMatrix Matrix
        {
            get
            {
                var scale = SKMatrix.CreateScale(Zoom, Zoom);
                var trans = SKMatrix.CreateTranslation(PanX, PanY);
                // сначала Scale, потом Translate
                return scale.PostConcat(trans);
            }
        }

        public SKMatrix InverseMatrix
        {
            get
            {
                if (Matrix.TryInvert(out var inv))
                    return inv;
                return SKMatrix.CreateIdentity();
            }
        }

        public void ZoomAt(float factor, SKPoint screenPoint)
        {
            var before = InverseMatrix.MapPoint(screenPoint);
            Zoom *= factor;
            var after = InverseMatrix.MapPoint(screenPoint);
            PanX += (after.X - before.X) * Zoom;
            PanY += (after.Y - before.Y) * Zoom;
        }
    }
}

Файл: PipeProfileAppMaui\ViewModels\GroundViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using PipeProfileAppMaui.Models;
using System.Collections.ObjectModel;

public partial class GroundViewModel : ObservableObject
{
    public ObservableCollection<GroundPoint> GroundPoints { get; }

    public GroundViewModel()
    {
        GroundPoints = new ObservableCollection<GroundPoint>();
        GroundPoints.CollectionChanged += (_, __) =>
        {
            // пересчёт индексов после добавления/удаления
            int idx = 1;
            foreach (var p in GroundPoints)
                p.Index = idx++;
        };
        GroundPoints.Add(new GroundPoint { Distance_m = 0, Elevation_cm = 100 });
        GroundPoints.Add(new GroundPoint { Distance_m = 10, Elevation_cm = 200 });
        GroundPoints.Add(new GroundPoint { Distance_m = 13, Elevation_cm = 500 });
        GroundPoints.Add(new GroundPoint { Distance_m = 35, Elevation_cm = 550 });
        GroundPoints.Add(new GroundPoint { Distance_m = 70, Elevation_cm = 600 });

    }

    [RelayCommand]
    void AddPoint()
    {
        GroundPoints.Add(new GroundPoint { Distance_m = 0, Elevation_cm = 0 });
    }

    [RelayCommand]
    void RemovePoint(GroundPoint p)
    {
        if (p != null) GroundPoints.Remove(p);
    }

    [RelayCommand]
    void IncreaseDistance(GroundPoint p)
        => p.Distance_m++;

    [RelayCommand]
    void DecreaseDistance(GroundPoint p)
    {
        if (p.Distance_m > 0) p.Distance_m--;
    }

    public double InterpolateGroundElevation(double distance)
    {
        if (GroundPoints.Count == 0)
            return 0f;
        if (distance <= GroundPoints[0].Distance_m)
            return (float)GroundPoints[0].Elevation_cm;
        if (distance >= GroundPoints[^1].Distance_m)
            return (float)GroundPoints[^1].Elevation_cm;

        for (int i = 0; i < GroundPoints.Count - 1; i++)
        {
            var p0 = GroundPoints[i];
            var p1 = GroundPoints[i + 1];
            if (distance >= p0.Distance_m && distance <= p1.Distance_m)
            {
                float t = (float)((distance - p0.Distance_m) / (p1.Distance_m - p0.Distance_m));
                return (1 - t) * (float)p0.Elevation_cm + t * (float)p1.Elevation_cm;
            }
        }
        return (double)GroundPoints[^1].Elevation_cm;
    }

}

Файл: PipeProfileAppMaui\ViewModels\MainViewModel.cs
// File: Controls/MainViewModel.cs

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using PipeProfileAppMaui.Helpers;
using PipeProfileAppMaui.Models;
using PipeProfileAppMaui.Transforms;
using SkiaSharp;
using System.Collections.ObjectModel;
using System.Text.Json;

namespace PipeProfileAppMaui.ViewModels
{
    public partial class MainViewModel : ObservableObject
    {
       public PipeViewModel PipeVm { get; }
       public GroundViewModel GroundVm { get; }

        // 1) Сырая матрица строк (11 строк по 12 столбцов)
        static readonly string[][] _initialStampText = new[]
        {
            new[]{ "",   "",   "",   "",   ".",  "",     "",     "",     "",     "",     "",     ""    },
            new[]{ "",   "",   "",   "",   "",    "",     "",     "",     "",     "",     "",     ""    },
            new[]{ "",   "",   "",   "",   "",    "",     "",     "",     "",     "",     "",     ""    },
            new[]{ "",   "",   "",   "",   "",    "",     "",     "",     "",     "",     "",     ""    },
            new[]{ "Изм.","Лист","№ Документ","Подпись","Дата","", "",    "",     "",     "",     "",     "" },
            new[]{ "Исп.            ","",   "",   "",   "",    "",     "Стадия","",    "",     "Лист","",     "Листов" },
            new[]{ "Пров.          ","",  "",   "",   "",    "",     "",     "",     "",     "1",    "",     "1"   },
            new[]{ "Пров.          ","",  "",   "",   "",    "",     "",     "",     "",     "",     "",     ""    },
            new[]{ "Пров.          ","",  "",   "",   "",    "",     "",     "",     "",     "",     "",     ""    },
            new[]{ "",   "",   "",   "",   "",    "",     "",     "",     "",     "",     "",     ""    },
            new[]{ "",   "",   "",   "",   "",    "",     "",     "",     "",     "",     "",     ""    },
        };


        [ObservableProperty]
        private double mouseX;
        [ObservableProperty]
        private double mouseY;

        // === 1) Состояние маркеров ===
        [ObservableProperty]
        private bool showMarkers = true;

        // === 2) Команда-переключатель ===
        [RelayCommand]
        private void ToggleShowMarkers()
            => ShowMarkers = !ShowMarkers;

        [ObservableProperty]
        private string screenOffsetRatioDisplay = "—";

        public ObservableCollection<ObservableCollection<StampCell>> StampCells { get; }
        public ViewTransform Transform { get; } = new ViewTransform();

        // Списки точек и флаги UI

        [ObservableProperty]
        private bool showPointNumbers;

        //[ObservableProperty]
        //private float zoomLevel = 1f;

        [ObservableProperty]
        private float panX;

        [ObservableProperty]
        private float panY;

        public MainViewModel()
        {
            // 1) создаём «дочерние» VM
            GroundVm = new GroundViewModel();
            PipeVm = new PipeViewModel();

            StampCells = new ObservableCollection<ObservableCollection<StampCell>>(
            _initialStampText
                .Select(row =>
                    new ObservableCollection<StampCell>(
                        row.Select(text => new StampCell { Text = text })
                    )
                )
            );
        }

        // Toggle отрисовки номеров точек
        [RelayCommand]
        void ToggleShowPointNumbers()
            => ShowPointNumbers = !ShowPointNumbers;

        // Сохранить в файл
        [RelayCommand]
        public async Task SaveToFileAsync()
        {
            var data = new ProfileData
            {
                GroundPoints = GroundVm.GroundPoints,
                PipePoints = PipeVm.PipePoints
            };
            var json = JsonSerializer.Serialize(data, new JsonSerializerOptions { WriteIndented = true });
            var path = Path.Combine(FileSystem.AppDataDirectory, "profile.json");
            await File.WriteAllTextAsync(path, json);
        }

        // Сохранить как pdf
        [RelayCommand]
        public async Task SavePdfAsync()
        {
            var file = Path.Combine(FileSystem.AppDataDirectory, "sheet.pdf");
            using var doc = SKDocument.CreatePdf(file);
            var canvas = doc.BeginPage(595, 842); // A4 в 72 DPI
            //Draw(canvas, new SKImageInfo(595, 842));
            doc.EndPage();
            doc.Close();
            var f = this.ToString();
            await Shell.Current.DisplayAlert("PDF", $"Сохранено в:\n{file}", "OK");
        }

        // Загрузить из файла
        [RelayCommand]
        public async Task LoadFromFileAsync()
        {
            var path = Path.Combine(FileSystem.AppDataDirectory, "profile.json");
            if (!File.Exists(path)) return;

            var json = await File.ReadAllTextAsync(path);
            var data = JsonSerializer.Deserialize<ProfileData>(json);
            if (data == null) return;

            GroundVm.GroundPoints.Clear();
            foreach (var gp in data.GroundPoints) GroundVm.GroundPoints.Add(gp);

            PipeVm.PipePoints.Clear();
            foreach (var pp in data.PipePoints) PipeVm.PipePoints.Add(pp);
        }


        // Внутренний класс для сериализации
        private class ProfileData
        {
            public ObservableCollection<GroundPoint> GroundPoints { get; set; } = new();
            public ObservableCollection<PipePoint> PipePoints { get; set; } = new();
        }
        /// <summary>
        /// Рисует профиль: применяем Pan/Zoom и отрисовываем базовую сетку + линии.
        /// </summary>

        // Вспомогательный метод для линейной интерполяции уровня грунта
    }
}

Файл: PipeProfileAppMaui\ViewModels\PipeViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using PipeProfileAppMaui.Models;
using System.Collections.ObjectModel;

public partial class PipeViewModel : ObservableObject
{
    public ObservableCollection<PipePoint> PipePoints { get; }

    public PipeViewModel()
    {
        PipePoints = new ObservableCollection<PipePoint>();
        PipePoints.CollectionChanged += (_, __) =>
        {
            int idx = 1;
            foreach (var p in PipePoints)
                p.Index = idx++;
        };
        PipePoints.Add(new PipePoint { Distance_m = 0, Depth_cm = 150 });
        PipePoints.Add(new PipePoint { Distance_m = 8, Depth_cm = 270 });
        PipePoints.Add(new PipePoint { Distance_m = 10, Depth_cm = 390 });
        PipePoints.Add(new PipePoint { Distance_m = 34, Depth_cm = 300 });
        PipePoints.Add(new PipePoint { Distance_m = 60, Depth_cm = 200 });
    }

    [RelayCommand]
    void AddPipePoint()
        => PipePoints.Add(new PipePoint { Distance_m = 0, Depth_cm = 0 });

    [RelayCommand]
    void RemovePipePoint(PipePoint p)
    {
        if (p != null) PipePoints.Remove(p);
    }

    [RelayCommand]
    void IncreasePipeDistance(PipePoint p)
        => p.Distance_m++;

    [RelayCommand]
    void DecreasePipeDistance(PipePoint p)
    {
        if (p.Distance_m > 0) p.Distance_m--;
    }
}

Файл: PipeProfileAppMaui\ViewModels\RibbonButtonItem.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace PipeProfileAppMaui.ViewModels
{
    public class RibbonLabelItem : IRibbonItem, INotifyPropertyChanged
    {
        private readonly INotifyPropertyChanged _source;
        private readonly PropertyInfo _prop;

        public RibbonLabelItem(INotifyPropertyChanged source, string propertyName)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            _source = source;
            // найдём PropertyInfo один раз
            _prop = source.GetType().GetProperty(propertyName)
                    ?? throw new ArgumentException($"Property {propertyName} not found");

            // подпишемся на уведомления
            _source.PropertyChanged += OnSourcePropertyChanged;
            // и сразу инициализируем Text
            Text = _prop.GetValue(_source)?.ToString() ?? string.Empty;
        }

        private void OnSourcePropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == _prop.Name)
            {
                // обновляем наше Text-свойство
                Text = _prop.GetValue(_source)?.ToString() ?? string.Empty;
            }
        }

        private string _text = string.Empty;
        public string Text
        {
            get => _text;
            private set
            {
                if (_text != value)
                {
                    _text = value;
                    PropertyChanged?.Invoke(this,
                        new PropertyChangedEventArgs(nameof(Text)));
                }
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;
    }
}


Файл: PipeProfileAppMaui\ViewModels\RibbonItems.cs
// в ViewModels/RibbonItems.cs
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Input;

namespace PipeProfileAppMaui.ViewModels
{
    public interface IRibbonItem { }

    public class RibbonButtonItem : IRibbonItem
    {
        public string Text { get; }
        public ICommand Command { get; }
        public RibbonButtonItem(string text, ICommand cmd)
        {
            Text = text; Command = cmd;
        }
    }

    public class RibbonTab
    {
        public string Header { get; }
        public ObservableCollection<IRibbonItem> Items { get; }
        public RibbonTab(string header, IEnumerable<IRibbonItem> items)
        {
            Header = header;
            Items = new ObservableCollection<IRibbonItem>(items);
        }
    }
}

Файл: PipeProfileAppMaui\ViewModels\RibbonItemTemplateSelector.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PipeProfileAppMaui.ViewModels
{
    public class RibbonItemTemplateSelector : DataTemplateSelector
    {
        public DataTemplate ButtonTemplate { get; set; }
        public DataTemplate LabelTemplate { get; set; }

        protected override DataTemplate OnSelectTemplate(object item, BindableObject container)
        {
            return item switch
            {
                RibbonButtonItem => ButtonTemplate,
                RibbonLabelItem => LabelTemplate,
                _ => null
            };
        }
    }
}


Файл: PipeProfileAppMaui\ViewModels\RibbonViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;
using System.Windows.Input;

namespace PipeProfileAppMaui.ViewModels
{
    public partial class RibbonViewModel : ObservableObject
    {
        public ObservableCollection<RibbonTab> RibbonTabs { get; } = new();

        [ObservableProperty]
        RibbonTab _selectedRibbonTab;

        [ObservableProperty]
        private int _selectedTabIndex;

        public RibbonViewModel(MainViewModel mainVm)
        {
            var labelItem = new RibbonLabelItem(
            source: mainVm,
            propertyName: nameof(mainVm.ScreenOffsetRatioDisplay));

            // 1) домашние кнопки
            var homeItems = new List<IRibbonItem>
            {
                  new RibbonButtonItem("💾 PDF",    mainVm.SavePdfCommand),
                  new RibbonButtonItem("📂 Загрузить", mainVm.LoadFromFileCommand),
                  new RibbonButtonItem("🔢 Точки", mainVm.ToggleShowPointNumbersCommand),
            };
            // 2) метка-лейбл для ratio
            homeItems.Add(labelItem);

            // 4) вкладка «Главная»
            RibbonTabs.Add(new RibbonTab("Главная", homeItems));

            // 5) вкладка «Вставка»
            var insertItems = new IRibbonItem[]
            {
              new RibbonButtonItem("➕ Грунт", mainVm.GroundVm.AddPointCommand),
              new RibbonButtonItem("➕ Труба", mainVm.PipeVm.AddPipePointCommand)
            };
            RibbonTabs.Add(new RibbonTab("Вставка", insertItems));

            SelectedTabIndex = 0;
            SelectedRibbonTab = RibbonTabs[0];
        }

        partial void OnSelectedTabIndexChanged(int oldIndex, int newIndex)
        {
            if (newIndex >= 0 && newIndex < RibbonTabs.Count)
                SelectedRibbonTab = RibbonTabs[newIndex];
        }

        partial void OnSelectedRibbonTabChanged(RibbonTab oldTab, RibbonTab newTab)
        {
            var idx = RibbonTabs.IndexOf(newTab);
            if (idx >= 0)
                SelectedTabIndex = idx;
        }

        [RelayCommand]
        void SelectTab(RibbonTab tab)
          => SelectedRibbonTab = tab;
    }
}

Файл: PipeProfileAppMaui\Platforms\Android\MainActivity.cs
using Android.App;
using Android.Content.PM;
using Android.OS;

namespace PipeProfileAppMaui
{
    [Activity(Theme = "@style/Maui.SplashTheme", MainLauncher = true, LaunchMode = LaunchMode.SingleTop, ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation | ConfigChanges.UiMode | ConfigChanges.ScreenLayout | ConfigChanges.SmallestScreenSize | ConfigChanges.Density)]
    public class MainActivity : MauiAppCompatActivity
    {
    }
}


Файл: PipeProfileAppMaui\Platforms\Android\MainApplication.cs
using Android.App;
using Android.Runtime;

namespace PipeProfileAppMaui
{
    [Application]
    public class MainApplication : MauiApplication
    {
        public MainApplication(IntPtr handle, JniHandleOwnership ownership)
            : base(handle, ownership)
        {
        }

        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
    }
}


Файл: PipeProfileAppMaui\Platforms\iOS\AppDelegate.cs
using Foundation;

namespace PipeProfileAppMaui
{
    [Register("AppDelegate")]
    public class AppDelegate : MauiUIApplicationDelegate
    {
        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
    }
}


Файл: PipeProfileAppMaui\Platforms\iOS\Program.cs
using ObjCRuntime;
using UIKit;

namespace PipeProfileAppMaui
{
    public class Program
    {
        // This is the main entry point of the application.
        static void Main(string[] args)
        {
            // if you want to use a different Application Delegate class from "AppDelegate"
            // you can specify it here.
            UIApplication.Main(args, null, typeof(AppDelegate));
        }
    }
}


Файл: PipeProfileAppMaui\Platforms\MacCatalyst\AppDelegate.cs
using Foundation;

namespace PipeProfileAppMaui
{
    [Register("AppDelegate")]
    public class AppDelegate : MauiUIApplicationDelegate
    {
        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
    }
}


Файл: PipeProfileAppMaui\Platforms\MacCatalyst\Program.cs
using ObjCRuntime;
using UIKit;

namespace PipeProfileAppMaui
{
    public class Program
    {
        // This is the main entry point of the application.
        static void Main(string[] args)
        {
            // if you want to use a different Application Delegate class from "AppDelegate"
            // you can specify it here.
            UIApplication.Main(args, null, typeof(AppDelegate));
        }
    }
}


Файл: PipeProfileAppMaui\Platforms\Tizen\Main.cs
using System;
using Microsoft.Maui;
using Microsoft.Maui.Hosting;

namespace PipeProfileAppMaui
{
    internal class Program : MauiApplication
    {
        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();

        static void Main(string[] args)
        {
            var app = new Program();
            app.Run(args);
        }
    }
}


Файл: PipeProfileAppMaui\Platforms\Windows\App.xaml
<maui:MauiWinUIApplication
    x:Class="PipeProfileAppMaui.WinUI.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:maui="using:Microsoft.Maui"
    xmlns:local="using:PipeProfileAppMaui.WinUI">

</maui:MauiWinUIApplication>


Файл: PipeProfileAppMaui\Platforms\Windows\App.xaml.cs
using Microsoft.UI.Xaml;

// To learn more about WinUI, the WinUI project structure,
// and more about our project templates, see: http://aka.ms/winui-project-info.

namespace PipeProfileAppMaui.WinUI
{
    /// <summary>
    /// Provides application-specific behavior to supplement the default Application class.
    /// </summary>
    public partial class App : MauiWinUIApplication
    {
        /// <summary>
        /// Initializes the singleton application object.  This is the first line of authored code
        /// executed, and as such is the logical equivalent of main() or WinMain().
        /// </summary>
        public App()
        {
            this.InitializeComponent();
        }

        protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
    }

}


Файл: PipeProfileAppMaui\Resources\Styles\Colors.xaml
<?xml version="1.0" encoding="UTF-8" ?>
<?xaml-comp compile="true" ?>
<ResourceDictionary 
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">

    <!-- Note: For Android please see also Platforms\Android\Resources\values\colors.xml -->

    <Color x:Key="Primary">#512BD4</Color>
    <Color x:Key="PrimaryDark">#ac99ea</Color>
    <Color x:Key="PrimaryDarkText">#242424</Color>
    <Color x:Key="Secondary">#DFD8F7</Color>
    <Color x:Key="SecondaryDarkText">#9880e5</Color>
    <Color x:Key="Tertiary">#2B0B98</Color>

    <Color x:Key="White">White</Color>
    <Color x:Key="Black">Black</Color>
    <Color x:Key="Magenta">#D600AA</Color>
    <Color x:Key="MidnightBlue">#190649</Color>
    <Color x:Key="OffBlack">#1f1f1f</Color>

    <Color x:Key="Gray100">#E1E1E1</Color>
    <Color x:Key="Gray200">#C8C8C8</Color>
    <Color x:Key="Gray300">#ACACAC</Color>
    <Color x:Key="Gray400">#919191</Color>
    <Color x:Key="Gray500">#6E6E6E</Color>
    <Color x:Key="Gray600">#404040</Color>
    <Color x:Key="Gray900">#212121</Color>
    <Color x:Key="Gray950">#141414</Color>

    <SolidColorBrush x:Key="PrimaryBrush" Color="{StaticResource Primary}"/>
    <SolidColorBrush x:Key="SecondaryBrush" Color="{StaticResource Secondary}"/>
    <SolidColorBrush x:Key="TertiaryBrush" Color="{StaticResource Tertiary}"/>
    <SolidColorBrush x:Key="WhiteBrush" Color="{StaticResource White}"/>
    <SolidColorBrush x:Key="BlackBrush" Color="{StaticResource Black}"/>

    <SolidColorBrush x:Key="Gray100Brush" Color="{StaticResource Gray100}"/>
    <SolidColorBrush x:Key="Gray200Brush" Color="{StaticResource Gray200}"/>
    <SolidColorBrush x:Key="Gray300Brush" Color="{StaticResource Gray300}"/>
    <SolidColorBrush x:Key="Gray400Brush" Color="{StaticResource Gray400}"/>
    <SolidColorBrush x:Key="Gray500Brush" Color="{StaticResource Gray500}"/>
    <SolidColorBrush x:Key="Gray600Brush" Color="{StaticResource Gray600}"/>
    <SolidColorBrush x:Key="Gray900Brush" Color="{StaticResource Gray900}"/>
    <SolidColorBrush x:Key="Gray950Brush" Color="{StaticResource Gray950}"/>
</ResourceDictionary>

Файл: PipeProfileAppMaui\Resources\Styles\Styles.xaml
<?xml version="1.0" encoding="UTF-8" ?>
<?xaml-comp compile="true" ?>

<ResourceDictionary 
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">

    <!-- задаём alias как AppFont -->
    <OnPlatform x:Key="AppFont" x:TypeArguments="x:String">
        <On Platform="Android"       Value="GOST_Type_AU" />
        <On Platform="iOS"           Value="GOST_Type_AU" />
        <On Platform="MacCatalyst"   Value="GOST_Type_AU" />
        <On Platform="WinUI"         Value="GOST_Type_AU" />
        <On Platform="Tizen"         Value="GOST_Type_AU" />
    </OnPlatform>
    
    <Style TargetType="ActivityIndicator">
        <Setter Property="Color" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
    </Style>

    <Style TargetType="IndicatorView">
        <Setter Property="IndicatorColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}"/>
        <Setter Property="SelectedIndicatorColor" Value="{AppThemeBinding Light={StaticResource Gray950}, Dark={StaticResource Gray100}}"/>
    </Style>

    <Style TargetType="Border">
        <Setter Property="Stroke" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
        <Setter Property="StrokeShape" Value="Rectangle"/>
        <Setter Property="StrokeThickness" Value="1"/>
    </Style>

    <Style TargetType="BoxView">
        <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource Gray950}, Dark={StaticResource Gray200}}" />
    </Style>

    <Style TargetType="Button">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource PrimaryDarkText}}" />
        <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource PrimaryDark}}" />
        <Setter Property="FontFamily" Value="OpenSansRegular" />
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="BorderWidth" Value="0"/>
        <Setter Property="CornerRadius" Value="8"/>
        <Setter Property="Padding" Value="14,10"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray950}, Dark={StaticResource Gray200}}" />
                            <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                    <VisualState x:Name="PointerOver" />
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="CheckBox">
        <Setter Property="Color" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="Color" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="DatePicker">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Editor">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="PlaceholderColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Entry">
        <Setter Property="FontFamily" Value="OpenSansRegular" />
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="PlaceholderColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Frame">
        <Setter Property="HasShadow" Value="False" />
        <Setter Property="BorderColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray950}}" />
        <Setter Property="CornerRadius" Value="8" />
        <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource Black}}" />
    </Style>

    <Style TargetType="ImageButton">
        <Setter Property="Opacity" Value="1" />
        <Setter Property="BorderColor" Value="Transparent"/>
        <Setter Property="BorderWidth" Value="0"/>
        <Setter Property="CornerRadius" Value="0"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="Opacity" Value="0.5" />
                        </VisualState.Setters>
                    </VisualState>
                    <VisualState x:Name="PointerOver" />
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Label">
        <Setter Property="FontFamily" Value="{StaticResource AppFont}" />
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Span">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
    </Style>

    <Style TargetType="Label" x:Key="Headline">
        <Setter Property="FontFamily" Value="{StaticResource AppFont}" />
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource MidnightBlue}, Dark={StaticResource White}}" />
        <Setter Property="FontSize" Value="32" />
        <Setter Property="HorizontalOptions" Value="Center" />
        <Setter Property="HorizontalTextAlignment" Value="Center" />
    </Style>

    <Style TargetType="Label" x:Key="SubHeadline">
        <Setter Property="FontFamily" Value="{StaticResource AppFont}" />
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource MidnightBlue}, Dark={StaticResource White}}" />
        <Setter Property="FontSize" Value="24" />
        <Setter Property="HorizontalOptions" Value="Center" />
        <Setter Property="HorizontalTextAlignment" Value="Center" />
    </Style>

    <Style TargetType="ListView">
        <Setter Property="SeparatorColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
        <Setter Property="RefreshControlColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource Gray200}}" />
    </Style>

    <Style TargetType="Picker">
        <Setter Property="FontFamily" Value="{StaticResource AppFont}" />
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="TitleColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource Gray200}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                            <Setter Property="TitleColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="ProgressBar">
        <Setter Property="ProgressColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="ProgressColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="RadioButton">
        <Setter Property="BackgroundColor" Value="Transparent"/>
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="RefreshView">
        <Setter Property="RefreshColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource Gray200}}" />
    </Style>

    <Style TargetType="SearchBar">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="PlaceholderColor" Value="{StaticResource Gray500}" />
        <Setter Property="CancelButtonColor" Value="{StaticResource Gray500}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                            <Setter Property="PlaceholderColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="SearchHandler">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="PlaceholderColor" Value="{StaticResource Gray500}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                            <Setter Property="PlaceholderColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Shadow">
        <Setter Property="Radius" Value="15" />
        <Setter Property="Opacity" Value="0.5" />
        <Setter Property="Brush" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource White}}" />
        <Setter Property="Offset" Value="10,10" />
    </Style>

    <Style TargetType="Slider">
        <Setter Property="MinimumTrackColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="MaximumTrackColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray600}}" />
        <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="MinimumTrackColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}"/>
                            <Setter Property="MaximumTrackColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}"/>
                            <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}"/>
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="SwipeItem">
        <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource Black}}" />
    </Style>

    <Style TargetType="Switch">
        <Setter Property="OnColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="ThumbColor" Value="{StaticResource White}" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="OnColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                            <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                    <VisualState x:Name="On">
                        <VisualState.Setters>
                            <Setter Property="OnColor" Value="{AppThemeBinding Light={StaticResource Secondary}, Dark={StaticResource Gray200}}" />
                            <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
                        </VisualState.Setters>
                    </VisualState>
                    <VisualState x:Name="Off">
                        <VisualState.Setters>
                            <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Gray400}, Dark={StaticResource Gray500}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="TimePicker">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent"/>
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Page" ApplyToDerivedTypes="True">
        <Setter Property="Padding" Value="0"/>
        <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource OffBlack}}" />
    </Style>

    <Style TargetType="Shell" ApplyToDerivedTypes="True">
        <Setter Property="Shell.BackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource OffBlack}}" />
        <Setter Property="Shell.ForegroundColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource SecondaryDarkText}}" />
        <Setter Property="Shell.TitleColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource SecondaryDarkText}}" />
        <Setter Property="Shell.DisabledColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray950}}" />
        <Setter Property="Shell.UnselectedColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray200}}" />
        <Setter Property="Shell.NavBarHasShadow" Value="False" />
        <Setter Property="Shell.TabBarBackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource Black}}" />
        <Setter Property="Shell.TabBarForegroundColor" Value="{AppThemeBinding Light={StaticResource Magenta}, Dark={StaticResource White}}" />
        <Setter Property="Shell.TabBarTitleColor" Value="{AppThemeBinding Light={StaticResource Magenta}, Dark={StaticResource White}}" />
        <Setter Property="Shell.TabBarUnselectedColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource Gray200}}" />
    </Style>

    <Style TargetType="NavigationPage">
        <Setter Property="BarBackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource OffBlack}}" />
        <Setter Property="BarTextColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource White}}" />
        <Setter Property="IconColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource White}}" />
    </Style>

    <Style TargetType="TabbedPage">
        <Setter Property="BarBackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource Gray950}}" />
        <Setter Property="BarTextColor" Value="{AppThemeBinding Light={StaticResource Magenta}, Dark={StaticResource White}}" />
        <Setter Property="UnselectedTabColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray950}}" />
        <Setter Property="SelectedTabColor" Value="{AppThemeBinding Light={StaticResource Gray950}, Dark={StaticResource Gray200}}" />
    </Style>

    <!-- Применяется ко всем Label и его потомкам -->

</ResourceDictionary>


Файл: PipeProfileAppMaui\Resources\Styles\TabStyles.xaml
<?xml version="1.0" encoding="UTF-8" ?>
<?xaml-comp compile="true" ?>
<ResourceDictionary 
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">

    <Style x:Key="TabIconStyle" TargetType="Image">
        <Setter Property="WidthRequest" Value="32"/>
        <Setter Property="HeightRequest" Value="32"/>
        <Setter Property="VerticalOptions" Value="Start"/>
        <Setter Property="HorizontalOptions" Value="Center"/>
        <Setter Property="Margin" Value="0,6,0,0"/>
    </Style>

</ResourceDictionary>

